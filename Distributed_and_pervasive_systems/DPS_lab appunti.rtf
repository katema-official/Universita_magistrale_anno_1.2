{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1040{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\b\f0\fs52\lang16 Distributed and Pervasive Systems - Lab (appunti)\par
\b0\fs22\par
Lezione 1 - 08/04/2022\par
We'll see concurrent servers with threads. We'll see how to sync them. Then we'll see how different machines can communicate with different protocols. Then we'll see RPC and then how to develop REST servers and the MQTT protocol. Four lessons in total. Also, the following lessons will be about the project. We can present the project only after the theory exam mark (the end of may). The last lab lesson is used to presend the project (extra session). The project discussion lasts half an hour, we have to describe the structure of the project and development. Then execute the code in our machine, they can ask something about the code and some questions about the lab part of the course. We'll use Java for this project, and during the lessons we'll see exercises that we'll solve using Intellij. It is not mandatory intellij, but it's better. Plagiarism: the project must be individual. We can't even use same small pieces of code. We'll see some implementations that are low level in java, even if nowdays we have high level libraries to do synchronizations. But using low level primitives we'll better understand what is behind those libraries. tutorsdp@di.unimi.it for doubts.\par
We'll see the client-server paradigm, iterative servers, Multi-threaded servers and thread synchronization. \line Client-server paradigm: the client asks something to the server, and we have two sockets: one for the client and one for the server. The server creates a listening socket, in which he specifies the port number associated with the service. The client reaches out the socket of the server. At this point, the server creates an establish socket that is used to do the true communication. Let's start from iterative servers: servers that can handle one client at a time. The server accepts a connection request, the cliend sends a request, and the server receives it. During its processing, other clients must wait. \line How to implement in Java this server? UpperCaseServer (the one I downloaded yesterday).\line inputStream: stream for reading data, outputStream: to send data. BufferedReader: used to manage a buffer of characters. \line If another client tries to reach out the server while it is busy, it waits (blocking call) until it is free.\par
Threads: different execution sequences within the same process, they share the same memory space and are scheduled as processes. We'll use them to build multi-threaded servers.\line To implement threads: we can inherit the Thread class. We redefine the constructor and the run() method. To invocate it, we create an instance and call the start() method. start() not run(), but you know it very well.\line Another way: class implementing Runnable interface. In the constructor we can pass different things. We can then implement run() and call start(). The last one is better >:( because the second one allows to extend another class that is not Thread.\line After the threads are invoked, they start running, and some code, in parallel, runs in the application. We have also father and child threads. The thread that calls start() is the father thread, and has a reference to it. If a father dies, the children dies (?). We can use threads to create a concurrent server where different requests can be handled in parallel. If there are multiple requests, they are queued and the server sequentially accepts them, but they are handled by single threads. The main server thread is the Dispatcher. \par
Exercise - A service for sums. We have to write a server that reads the port number of the service from command line. Prints address and port number of the connecting clients and sends back the sum of the two to the client.\line the client reads from the command line the address and port number of the servers. Then it reads two numbers and sends them to the server, then prints the result.\par
Done.\par
We've seen that multithreaded server are very cool, but sometimes debugging is a real hell. This is because we are in a concurrent environment, and we have parallel codes running all together. So different instructions can be executed simultaneously, also on different machines. The difficulty here is that the execution of the thread is not deterministic. So, different runs will produce different interleavings. We've seen that threadsa share the same memory space of a process: we need lock mechanisms. Vabb\'e8 concurrent access as always. \line In Java, each object has an "intrinsic lock" or monitor, and we can declared a method as synchronized. In this way, a therad that wants to execute it must first acquire a lock about the object on which the method is synchronized. The value of a lock of this kind is either available or not available.\line synchronized(object)\{\} -> everything we put inside is synchornized on that object. To synchronized on primitive types like int, float etc.. we have to create "dummy objects".\line long c1 = 0\line Object lock_c1 = new Object()\line synchronize(lock_c1).\par
if the method synchronized is STATIC, the intrinsic lock on which the synchronization os performed is the class itself (as synchronized(Foo.class) if it is used inside a static method). \par
Deadlock: of course a problem. We can order the locks to avoid it. \par
Volatile keyword. We've seen that synchronized is not used on variables, but volatile can (volatile int x). It's a lightweight version of the lock: grants visibility but not mutual exclusion. The atomicity is valid only for reading and writing on that a variable. x++ on a voltaile variable is not thread safe, because x++ is based on the state of the program (the current value of x). x = 10 is ok, is a direct writing operation. Really, volatile solves the problem of the caches in CPUs. \par
Exercise: the theater. Create a server that provides a theater service. Clients want to book tickets. The theater provides a single show and single type of ticket. The server is concurrent and can't sell more than the available tickets.\line If there are free seats, returns the number of RESERVED seats. if there are not, returns 0. \line Also one client can ask for one ticket at a time.\par
\par
Lezione 2 - 22/04/2022\par
Thread Signaling and M2M Communication\par
We'll see wait and notify and then XML and JSON to communicate between machines. Wait, notify, join and sleep can be used to coordinate the executions of more threads. \line The join() method is used to wait till the end of a thread. The caller stops until the joined method is called. An optional parameter, ms, can be bassed. It resumes the execution when the thread ends or when the timeout... times out. isAlive() can be used to query the state of a thread. Returns true if the thread is still in execution, false otherwise. \line The sleep() method is used to temporary stop the execution of the current thread. Should be used for debugging or to perform periodic actions. It's a static method of the Thread classe and the argument time is in milliseconds.\line wait() and notify(). These are methods of the OBJECT classe! Any object has associated a list of waiting threads. A thread can call wait() on a object waiting for another thread to call notify() on it. Wait(), too, has an optional timeout parameter. More threads can be waiting on the same object. notify() wakens only one random waiting thread (it is not granted that the order in which they are awakened is the same inwhich they have called the wait(). notifyAll awakens all of the waiting threads. \line If we use a wait inside a synchronized method, the waiting thread doesn't release the lock, so we'd have deadlock! Actually, this is FALSE! the wait() releases the intrinsic lock of the current object. If wait() is called before acquiring the lock, an exception is raised. When a thread is awakened from a wait, he must re-acquire the lock before continuing.\line For God's sake, DON'T EVER use the Thread.sleep() to stall the execution of a thread! Use instead wait() and notify(). \par
Let's see the java util.concurrent library. We can't use much... on the other end, we'll see how to implement the Producer-Consumer Pattern. It's a multi-process communication pattern where the producer is the entity (a thread for us) that sends some data, while the consumer is another entity that receives these data. Usually, a queue is used to transit the data. We can also have more producers and consumers.\par
Problem: we want a common way to represent data. So, marshalling and unmarshalling. We'll see three formats to do so: XML, JSON and Protocol Buffers. XML is a very used encoding information standard. Is both human and machine readable. JSON is a more recent standard, also readable, and has replaced XML. The trasmission is also quicker. GSON can be used! toJson() and fromJson(). \par
\par
Lezione 3 - 29/04/2022\par
We'll talk about protocol buffers (machine to machine communication method) and then gRPC (Remote Procedure Call) Framewoek. The Protocol Buffer mechanism has been proposed by Google, and it is more compact and quicker than XML and JSON. Datas are represented in a binary format, so it\'ecs more efficient. It's easy to use, because marshalling and unmarshalling is automatically performed. We just have to read and write the objects through the streams. We have to define a file with extension .proto, in which we have to indicate the fields of the message. Then we have to buld gradle and then it's possible to write code to send and receive messages.\line To define a message through protocol Buffer, we have- every message has fields that can be also messages. The fields are required, that is mandatory, optional, the field can be omitted, and repeated, that is the field can be repeated multiple times. \line Every field has a unique tag, that help back-compatibility and must be immutable. \par
The files .proto go in the main directory of src, in a proto directory, and start in upper case (Actor.proto)\par
in gRPC, we will call the asynchronous methods.\par
\par
Lezione 4 - 06/05/2022\par
Prender\'f2 davvero appunti? Probabilmente mi stufer\'f2 dopo 21 secondi.\par
REST and MQTT.\par
Rest is Representational State Transferm tgat enables M2M communication via HTTP. They rely on the Get, Post, Put and Delete methods of HTTP. Design principles:\line -Explicit use of HTTP methods\line -be "stateless"\line -each resource is identified by a URI and the structure of these resources is similar to the one of directories.\line -Use of XML and JSON.\par
A common mistake is to use GET when instead a PUT or POST would be more suited. \line Usually, REST requires the explicit use of HTTP methods. There is a one-to-one corrispondence bw CRUD and HTTP methods. \par
Penso siano passati i 21 secondi.\par
Va messo il costruttore vuoto nelle classi serializzate.\par
\par
\par
\par
\par
}
 