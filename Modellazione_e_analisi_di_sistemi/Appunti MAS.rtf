{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1040{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qc\f0\fs44\lang16 Modellazione e analisi di sistemi - Appunti\par

\pard\sa200\sl276\slmult1\qj\fs22 Lezione 1 - 28/02/2022\par
\par
Cosa studieremo in questo corso? In questo corso sono richieste competenze di un corso di logica, innanzitutto. Vediamo un attimo il perch\'e9 di questo corso all'interno di un percorso informatico (sicurezza lei dice, ma noi siamo della Gervasi Gang, GG). Abbiamo tutti fatto IS, e abbiamo affrontato il problema dell'attivit\'e0 di testing. Sviluppando software si seguono dei processi, e il software va realizzato in modo ingegneristico e deve avere la "reliability", ovvero affidabilit\'e0, cio\'e8 l'assenza di fallimenti in un lasso di tempo. Quindi, il sw deve comportarsi come vuole il cliente il pi\'f9 a lungo possibile. Se il sw devia dai requisiti, male, quello \'e8 un malfunzionamento. Se per\'f2 non si verificano per un po' di tempo, il sw \'e8 affidabile. Ma ancora meglio sarebbe avere un sw corretto, cio\'e8 che SEMPRE e COMUNQUE si comporta nel modo giusto, il sw. Queste qualit\'e0 vanno dimostrate, e come facciamo a dire che un sw \'e8 affidabile? Normalmente, molto testing. Si tratta di un'attivit\'e0 dove il sw viene esposto a una serie di scenari di esecuzione. Se mostra un malfunzionamento, cio\'e8 fa una cosa diversa da quella che mi aspetto, allora c'\'e8 un bug, e bisogna correggerlo. Fatto ci\'f2, di nuovo testing. Tuttavia \'e8 matematicamente dimostrato che il sw non pu\'f2 essere testato su tutti i possibili input. Quindi il sw viene rilasciato come affidabile, ma ci\'f2 non vuol dire che non esista uno scenario che non dimostra malfunzionamenti, perch\'e9 magari uno scenario negativo io non l'ho beccato. Sarebbe bellissimo dimostrare la correttezza del sw. Come si fa? Con strumenti avanzati e time consuming, ma appunto, non \'e8 banale impiegarli. Ci sono state, comunque, 10 situazioni di programmi con problemi software gravi che non erano stati trovati durante la validazione (testing). Alcuni esempi di fallimenti:\par
The Mats Climate Orbiter Catastrophe: orbita che non arriva su marte ma esplode prima dell'atterraggio in quanto, parte del sw che faceva funzionare la navicella, \'e8 stato commissionato ad un partner inglese che lo ha sviluppato usando i piedi come unit\'e0 di misura, e non il sistema metrico decimale. Quando tutto \'e8 stato messo insieme, non funzionava.\par
Ariane 5 Explosion: razzo che esplode mentre parte. Parte del sw dell'Ariane 4 veniva riciclato, ma i motori non erano "a conoscenza" del fatto che era cambiato il contesto.\par
Hole in the Ozone: della Nasa. Questo buco non \'e8 stato rilevato per tanti anni perch\'e9 la misurazione dell'ozono veniva misurata all'interno di un certo range di misurazione, ma il problema veniva evidenziato solo se si misuravano valori al di fuori di questo range.\par
Deadly Radiation therapy - Therac 25: sistema per la radioterapia, per curare i tumori. Ma per un problema sw le persone venivano sottoposte a radiazioni 100 volte superiori a quelle preventivate. Per un problema software, molte persone sono morte.\par
Il problema insomma \'e8 che abbiamo problemi safety-critical. Quindi riguardano la sicurezza, ma nel senso che il sw quando funziona non causa "cose cattive" all'ambiente (ogni sw \'e8 immperso in un ambiente, sia che si tratti di un ambiente fisico o umano). Questa era la sefety. La security invece \'e8 quando \'e8 l'ambiete a creare problemi al sistema. L'ambiente \'e8 vulnerabile, e quindi anche il sistema lo \'e8. Quando parliamo di sicurezza qui, intendiamo safety. I sistemi allora li distinguiamo tra safety critical e security critical. i primi sono tali per cui un malfunzionamento pu\'f2 avere conseguenze negative per le persone. Nello standard IEEE, \'e8 evidenziato che nel processo di sviluppo di sw medico, ci deve essere una fase di verifica (5.5). Ci sono vari enti predisposti, nel mondo, che richiedono una documentazione piena di evidenze e prove tali da provare che il sw sia sicuro. La fase di verifica, oltre a quella di testing, \'e8 necessaria. A dicembre del 2021, sono stare rilasciate patch di sicurezza per Windows. Pi\'f9 di 60 vulnerabilit\'e0 sono state corrette (spoofing, DoS, Elevation of Privilege, etc.). \par
Esistono persino modelli di sviluppo software security-critical (Capability Maturity Model Integration), che distingue verifica da testing. Quindi un prodotto buono deve essere safety e security critical. Per fare ci\'f2, serve la verifica. In questo corso vedremo come approcciarci al problema di verifica (on \'e8 testing o validazione). E' una attivit\'e0 human-intensive e richiede molte pi\'f9 skill. Noi vogliamo affrontare problemi di verifica per la safety.\par
Quindi, che faremo in questo corso? Presenteremo le tecniche per la modellazione everifica formale di sistemi hw/sw. hw/sw sono sistemi embedded, cio\'e8 hw che si interfaccia col sw. Dovremo fare modellazione e verifica formale insomma. Pensiamo al testing: se non ho il sw, non riesco a fare testing. Anche qui ci serve un manufatto su cui fare verifica: si tratta dei \b modelli. \b0 Useremo i linguaggi di specifica per scrivere modelli. Pensali come lingue con cui traduciamo i requisiti in qualcosa che tutti possiamo comprendere. Poi abbiamo bisogno di fondamenti teorici e metodologie di analisi. Quindi, linguaggi di specifica, come usarli, come fare attivit\'e0 di verifica e come usare strumenti automatici.\par
Impareremo due categorie di linguaggi di specifica: uno sugli automi e uno pi\'f9 simile alla logica (logica temporale).\par
Come analisi, distingueremo tra validazione e verifica (quest'ultima pi\'f9 forte). Come linguaggi ne vedremo due, uno basato sugli automi e uno sulla logica temporale. In un caso, modello il sistema come macchina che esegue. Nell'altro, si modella il sistema sulla base di propriet\'e0 che devono essere soddisfatte. Sugli automi, ripasseremo velocemente Abstract State Machine, un tipo particoalre di automa. Useremo anche un ambiente che ne permette la scrittura di scenari, verifica, etc.. Questi due mega-argomenti dei linguaggi poi si fonderanno insieme: avremo l'automa, le propriet\'e0 da verificare e i tool che verificano automaticamente.\par
Il tool che useremo sar\'e0 NuSMV, per scrivere le propriet\'e0. Faremo model checking e specificheremo propriet\'e0, tra cui: di raggiungibilit\'e0, di safety, di liveness, di fairness e assenza di deadlock. Liveness vuol dire che se un client chiede un servizio a un server, questo prima o poi glielo concede. Per garantire che una propriet\'e0 \'e8 vera, il sistema deve cercare di dimostrare quella propriet\'e0 in tutte le configurazioni in cui si pu\'f2 trovare. C'\'e8 anche, nei model checker, il problema della state explosion (non c'\'e8 abbastanza memoria per dimostrare tutto). Si pu\'f2 risolvere tagliando una parte del modello.\par
Dove studiare?\par
Abstract State Machines: a method for high-level system degind and analysis\par
Logic in Computer Science: modelling and reasoning about systems (2nd edition, 2004)\par
System and Software Verification model-checking techniques and tools\par
Software Reliability methods (per dopo il corso)\par
Esame: scritto e prova pratica. Domande e esercizi. La prova di laboratorio consiste nel dimostrare di saper usare l'ambiente attorno alle ASM. La prova scritta sono domande o esercizi.\par
\par
Cosa sono i metodi formali?\par
Si tratta di notazioni rigorose. Quando voglio esprimere in una logica normale "sto facendo lezione e c'\'e8 il sole", io sintentizzo le proposizioni (verbo, soggetto e complemento) con una lettera proposizionale e le unisco con operatori logici. Questo crea univocit\'e0 e ammazza l'ambiguit\'e0. Descriviamo insomma il nostro sistema in termini rigorosi e matematici, che ha simboli e significato (sintassi e semantica) [P and Q \'e8 un \b termine\b0 ]. Tutti i linguaggi avranno una notazione e un significato, che dobbiamo conoscere per costruire un modello, che descrive un sistema che fa calcoli. Ora, non bisogna essere per forza dei logici o matematici per fare cio\'f2: basta abituarsi a usare un nuovo linguaggio, come se fosse un linguaggio di programmazione. Ci sono poi tecniche per analizzare sistemi, che hanno un fondamento matematico. Ci sono insomma regole di dimostrazione che mi permettono di trasformare un predicato in un T o F. E lo posso fare perch\'e9 il mio modello supporta questo tipo di approccio. Insomma, ogni metodo formale \'e8 accompagnato da un metodo di verifica. Ora, modellare implica astrarre: cerchiamo di astrarre i dettagli dai requisiti per estrarre il vero comportamento del sistema, quello che davvero ci interessa. [UML non \'e8 un modello formale, altrimenti avrebbe accantoa  se approcci o tecniche per fare analisi, che invece non ha]. I vantaggi nell'uso dei metodi formali sono che possiamo descrivere il sistema in modo non ambiguo e univoco. Tutti insomma interpretiamo i requisiti allo stesso modo. Ogni modello inoltre va provato essere corretto, e abbiamo tecniche per farlo. Scrivendo dei modelli potremmo introdurre errori, ma poi possiamo trovarli grazie a questi strumenti e modificare il modello o i requisiti. A volte il modello va bene rispetto ai requisiti, ma dobbiamo cambiare i requisiti.\par
Quindi, scriviamo modelli con metodi formali: ma quanti metodi formali ci sono? Tantissimi. Non \'e8 come UML (unified... \'e8 uno standard aziendale), non ci sono standard. Ci\'f2 nonostante, questi formalismi possiamo dividerli in due categorie:\par
FORMALISMI OPERAZIONALI: descriviamo la macchina come un oggetto che computa. Mi dice come fare qualcosa per raggiungere lo scopo. Abbiamo: Abstract State machines, B method, Z method, SCR (Software Cost Reduction), Reti di Petri. Sono utili se vogliamo seguire la computazione del sistema, l'evoluzione insomma. Utili per la validazione.\par
FORMALISMI OPERAZIONALI: descriviamo un sistema in termini di propriet\'e0 che il sistema deve rispettare. Non mi dice come fare, mi dice cosa voglio. Abbiamo: Logica Temporale, Trio, Algebre dei processi. Ci servono per capire le propriet\'e0 che vogliamo soddisfare. Utili per la verifica.\par
Validazione: simile al testing (anzi, il testing \'e8 una forma di validazione). Il sistema soddisfa i requisiti specificati dal cliente.\par
Verifica: processo di valutare un sistema o una componente per determinare se i prodotti di una data fase di sviluppo sodisfano le propriet\'e0 imposte allo stato di tale fase. Si fa con dimostrazione di propriet\'e0, che di solito vengono effettuate mediante theorem prover e model checker. Model Checker: Modello + propriet\'e0 in pasto a una macchina = verifica, controesempio o memory exceeded. Theorem Prover: Modello + propriet\'e0 in pasto a una macchina, ma "tengo la mano" al dimostratore. L'utente insomma deve intervenire. Spesso con un theorem prover si arriva a un "dunque": siamo noi a dimostrare, quindi scegliamo un ramo di dimostrazione, e se ci porta a errori, possiamo fare backtracking. Noi faremo il model checker. [corso di Metodi Formali per fare anche theorem prover].\par
Cattivi preconcetti: la gente spesso diffida dall'usare i metodi formali, perch\'e9 pensa siano strettamente usati dai matematici. Inoltre si pensa che il processo di verifica sia soggetto ad errori: \'e8 vero, ma se non lo fai non hai la certificazione. Usare metodi formali, inoltre, rallenta lo sviluppo, ma se poi il prodotto \'e8 anche verificato posso provarne la correttezza, e quindi l'affidabilit\'e0 (no bug). \par
Esagerazioni: c'\'e8 chi pensa che la verifica formale sia il top che si pu\'f2 fare. Beh attenzione, perch\'e9 se io provo propriet\'e0 su un modello sbagliato, io non ho fatto niente praticamente. Insomma, non basta un modello e delle propriet\'e0 da provare. I modelli non sempre catturano i requisiti, bisogna fare attenzione. Poi, si dice anche che con la verifica il sw \'e8 sicuro (safety). In realt\'e0 per la complessit\'e0 odierna dei sw non si pu\'f2 avere la prova che l'intero sw sia corretto. Possiamo garantire l'assenza di fallimenti solo su piccoli pezzi del sistema, per l'intero \'e8 follia. Infine, si dice che il testing \'e8 il solo metodo usato nella pratica dalle industrie. Non \'e8 vero, anche la NASA lavora ai metodi formali, quindi sono importanti ANCHE loro.\par
Ebbene, impareremo: processo, come scrivere i modelli. La notazione appropriata, cio\'e8 ASM e Logica temporale. Infine i tools, ASMETA (ASM) e NuSVM (model checker e propriet\'e0 temporali). Ci saranno esercitazioni durante le lezioni di teoria. La prossima volta, ripasseremo le ASM. Le ASM sono un po' diverse dall SM che conosco: scriveremo praticamente un programma, non un diagramma. \par
\par
Lezione 2 - 07/03/2022\par
Automi per la specifica di sistemi (ripasso).\par
Logica proposizionale e dei predicati -> da ripassare (l'ho gi\'e0 quasi finito di fare).\par
La scorsa volta abbiamo visto che studieremo due formalismi utili a modellare e poi fare analisi su questi modelli. Il primo modello sono le ASM, e riprendono gli automi, e il secondo \'e8 la logica temporale. Entrambi questi modelli vanno basati sul concetto di automi. I nostri formalismi modellano un sistema, e si basano sul concetto di stato come istantanea di un sistema e il passaggio da uno stato al successivo mediante una transizione. Gli automi nascono come primo esempio di macchine capaci di riconoscere linguaggi, ma in generale vengono usati per modellare i sistemi. Prima di vedere i formalismi che useremo, ripassiamo gli automi. Questo concetto di automa infatti \'e8 nella pratica molto usato per fare uno sketch di un sistema che poi andr\'e0 implementato.\par
Un automa \'e8 matematicamente definito come una tupla di ingredienti:\par
-S, l'insieme degli stati, che sono in numero finito.\par
-I, insieme finito di eventi di input.\par
-sigma: S x I -> S, che \'e8 la funzione di transizione.\par
Ovvero, se sono in uncerto stato e applico un certo input, vado in uno stato successivo. Si rappresenta graficamente mediante un disegno dove gli stati sono dei cerchi e le transizioni (della funzione di transizione) sono delle frecce. Se vogliamo segnare uno stato iniziale, mettiamo una freccia che entra nello stato iniziale e che proviene dal "niente". Queste sono le macchine "di base", cio\'e8 che rispondono solo agli input. Vorremmo per\'f2 anche automi che cambiano l'ambiente, ma questo formalismo \'e8 troppo semplice per farlo.\par
Estensioni: macchine di Mealy. Le transizioni sono tuple del tipo (stato di partenza, input, output, stato di arrivo). Ovvero, dato uno stato e un input, va in un altro stato esponendo l'output sulla transizione. In una transizione, si scrive input/output per specificare che, a fronte dell'evento di input verificatosi, non solo si cambia di stato (basta seguire la direzione della freccia), ma si verifica anche un'azione rappresentata dall'output.\par
Tuttavia, io, con questo formalismo, non posso modellare macchine che, ad esmepio, mi scambiano monete. Tipo, immetto 10 monete da 10 cents e ricevo una moneta da un euro. Si tratta s\'ec di una macchina che ha input e output, ma che ha bisogno di ricordarsi delle cose. Le amcchine di Mealy non hanno memoria insomma. \par
L'estensione successiva \'e8 quindi quella della macchine a stati finiti estese. La transizione \'e8 ora una tupla (stato di partenza, input, output, guardia sulla memoria, azione di aggiornamento della memoria, stato di arrivo). La rappresentazione "a grafo" \'e8 come prima, ma abbiamo [coin=1] per le guardie, seguite dalle azioni del tipo "coin:=0". In pratica: se avviene un certo input e la guardia \'e8 vera, compio l'azione, emetto l'output e passo allo stato d'arrivo. Bisogna fare attenzione nelle guardie, perch\'e9 potremmo generare automi deterministici o non deterministici. Da notare come stiamo aggiungendo informazioni sulle transizioni. Un'osservazione: glis tati sono sempre cose semplici. Hanno solo un nome che raprpesenta la configurazione del sistema in un certo momento. Quello che non si riesce a fare con queste macchine sono i Sistemi Distribuiti. Immaginiamo un sistema produttore-consumatore. Potrei modellarlo con queste macchine, ma il numero di transizione esploderebbe. Perch\'e9 in uno stato devo tenere conto di cosa c'\'e8 nel consumatore, nel produttore e nel magazzino (?). Il passo successivo \'e8 quindi quello di definire le macchine di comunicazione.\par
Nelle macchine di comunicazione, ho:\par
-Una coppia (C,P), con C che sono i canali usati dai P processi per passarsi informazioni.\par
Dobbiamo immaginarci di avere tanti pezzi che comunicano tra di loro e possono anche comunicare con l'ambiente.\par
-Transizioni che sono: (s, c?i, s'), dove un pezzo legge informazioni da un canale (legge l'input i), (s, c!o, s'), dove invece si scrive su un canale l'output o e si passa a un altro stato. (s, null, s') per indicare che c'\'e8 stata una transizione da uno stato all'altro in un pezzo del sistema, ma non ha effetto sul canale.\par
E' arrivato poi UML con i suoi diagrammi, tra cui diagrammi per le amcchine di stato. Viene modellata come:\par
-Stati che hanno un nome e azioni di ingresso, l'attivit\'e0 che si compie mentre si \'e8 in quello stato, di uscita e eventi che, sulla base di alcune condizioni, compie azioni.\par
-Le transizioni anch'esse hanno un evento (l'input), una condizione (eventualmente) e un'azione.\par
UML cattura le macchine per Stati Finiti dividendo lo spazio in regioni parallele, dove ciascuna di esse ha una FSM che fa il suo lavoro e volendo comunica con le altre. In UML, la lettura di input \'e8 segnata come <<signal>>.\par
Ma la storia degli automi non finisce qua. Le ASM che studieremo sono un esempio di automa. Dobbiamo capire che il sistema ha una configurazione, una istantanea, che \'e8 lo stato, e transizioni che modificano lo stato. Tuttavia, per noi, questo stato che fino ad ora aveva semplicemente un nome, per noi sar\'e0 pieno di informazioni. Dopo pasqua vedremo anche gli automi di Kripke, dove lo stato \'e8 etichettato da lettere proposizionali. Lo stato, in questo caso, ci dice pi\'f9 che altro cosa \'e8 vero e cosa no in un certo stato (quale propriet\'e0 \'e8 valida in questo momento?).\par
\par
ASM\par
Le Abstract State Machines sono FSM cons"stati generalizzati", ovvero: mentre, finora, lo stato era uno stato cosiddetto "unstructured", ovvero dove non aveva una struttura se non per il nome, da ora in poi glis tati saranno strutturati. Lo stato \'e8 sempre modellato con un tondino (anche se poi lasceremo cadere la notazione grafica), ma in realt\'e0 per noi queste ASM saranno una sorta di pseudo-codifica. Useremo, per scrivere queste SM, un linguaggio di specifica. La principale differenza rispetto alle FSM \'e8 che questi stati sono strutturati. Ma cosa vuol dire? Viuol dire che lo stato diventa un'algebra, o "multi-sorted first-order structures". Io ad esempio voglio modellare un orologio che, in base al tempo corrente, visualizza il tempo in modo distreto ogni delta time. Quindi ho un orologio che, in base al tempo corrente, mi permette di vedere il tempo non in modo continuo ma a interalli di tempo (tipo ogni 5 secondi). Quali informazioni mi modelleranno questo fenomeno? Gli ingredienti che useremo per modellare li prendiamo dalla matematica. Cos'\'e8 un'algebra? Un insieme di simboli che hanno un'interpretazione. Nel nostro esempio, abbiamo la variabile CurrTime di tipo reale per ricordarci del tempo. La difficolt\'e0 di usare queste SM sar\'e0 usare la matematica per catturare quello che vogliamo dire. Poi abbiamo bisogno di qualcosa in cui mettere il tempo da visualizzare: DisplayTime, reale. Poi qualcosa che ci dica ogni quanto il tempo deve aggiornarsi: Delta, un reale (costante). Infine, una funzione + che va da Real x Real -> Real. Queste informazioni sono variabili, costanti. Tutte queste cose insieme costituiscono la mia algebra. Le variabili sono di fatto funzioni 0-arie.\par
Quindi, rappresentiamo lo stato attraverso un'algebra, con insiemi e funzioni. Gli stati sono strutturati. Multi-sorted = a pi\'f9 domini/sorti (interi, reali, insiemi definiti da me), first-order structure (perch\'e9 si usa la logica del primo ordine), o anche algebra. Lo stato di una ASM \'e8 un'algebra. Come cambia quest'algebra? Se l'istantanea di un sistema \'e8 un'algebra, la transizione ci fa passare da uno stato, un'algebra, a un altro/a. Anche le transizioni vengono espresse in modo testuale, e sono "regole" che descrivono il cambiamento di funzioni da unos tato al successivo. Abbiamo comunque dei costruttori di regola (modi ben definiti per cambiare lo stato). Esempio: if Condition then Updates. Con "update" intendiamo un aggiornamento dei domini o delle funzioni. Vedremo col tempo diversi costruttori di regole.\par
Con questi modelli, che noi esprimeremo come se fosse uno pseudolinguaggio, avremo a disposizione un ambiendi di sviluppo dove scriverli, un simulatore, che simula la macchina, tecniche di validazione, ovvero attivit\'e0 con cui controllo se il modello soddisfa i requisiti, meccanismi di verifica (via model checking) e generazione di casi di test (si possono generare partendo da modelli). Una ASM pu\'f2 essere vista come una pseudocodifica su strutture dati astratte (ADT). Questo ambiente, che useremo, \'e8 disponibile su github asmeta.github.io/ . Asmeta combina le ASM con meta modelling perch\'e9 questo ambiente \'e8 stato sviluppato usando la meta modellazione. \par
Le funzioni sono sempre definite su domini (impliciti o espliciti). Le regole di transizione le indichiamo come r_nome. Quando scatta una transizione, abbiamo un update, ovvero l'aggiornamento di una funzione. Cambia proprio l'algebra: o aggiorniamo gli insiemi, o aggiorniamo le funzioni.\par
Una ASM \'e8 definita da blocchi ben definitI: (header, body, main rule, initialization).\par
Header: parte iniziale che contiene il nome del file, l'import di alcune librerie, e signature, ovvero la definizione dei nostri domini e delle nostre funzioni. Si usano, in quest'ultimo caso, anche delle etichette. \b Controlled\b0 : funzioni che la macchina pu\'f2 leggere e scrivere. \b Monitored\b0 : i valori di queste funzioni arrivano dall'ambiente, sono input. \b Out\b0 : funzioni che la macchina scrive e che cambiano l'ambiente.\par
Body: le regole di transizione.\par
Main rule: ci permette di mettere in parallelo le regole. Noi siamo in uno stato, che \'e8 la nostra algebra, e se scattano tante transizioni, queste scattano contemporaneamente. NON C'E' SEQUENZA! la main rule con la parola par indica che tutte le transizioni vengono valutate contemporaneamente. C'\'e8 per\'f2 il rischio di creare inconsistenze di valori, visto che queste regole vengono eseguite insieme. Altri problemi sono sollevati dalla gestione di risorse (lock, deadlock). Ci sono situazioni comunque in cui pu\'f2 avere senso che scattino due regole contemporaneamente, basta che aggiornino porzioni separate dell'algebra, altrimenti nascono conflitti. \par
Nelle FSM, esiste un unico stato di controllo che pu\'f2 assumere valori in un insieme finito di un gerto tipo. Nelle ASM lo stato \'e8 pi\'f9 complesso.  Le condizioni di input e le azioni di output, nelle FSM, sono un alfabeto finito. Nelle ASM, l'input \'e8 qualsiasi espressione, e le azioni sono generiche.\par
Abbiamo un linguaggio per scrivere le ASM, ovvero AsmetaL. ha tanti tool tra cui uno per fare editing. Ogni tool ha il prefisso Asmeta-cosa che indica cosa fa il tool. \par
[Normalmente, la main rule amnda tutto in parallelo. Sta a me essere sicuro di non avere situazioni di conflitto.] Aggiungeremo delle invarianti del modello per dire che mai, nel modello, click e complete possono essere entrambe vere, perch\'e9 sarebbe un problema per il nostro sistema (esempio sulle slide).\par
\par
Lezione 3 - 10/03/2022\par
La scorsa volta abbiamo visto un paio di esempi e li abbiamo visti come macchine a stati, e poi abbiamo abbozzato un modello in ASM. Le ASM ereditano dalle SM il concetto di stato e transizione. Ma nelle ASM abbiamo un algebra per ogni stato, cio\'e8 funzioni e insiemi, e le transizioni sono date da regole.\par
Allora, noi abbiamo funzioni, ma uno stato pu\'f2 essere rappresentato come una locazione. Ad ogni stato s sono asccociati valori di qualsiasi tipo conservati in una locazione (come un cassetto). Uno stato \'e8 un insieme di cassetti, e ciascuno di loro ha unu nome che ha al suo interno un valore. Se uno stato quindi \'e8 questo insieme di cassetti con dentro valori, quando io cambio stato cambio algebra, ovvero insieme di cassetti. Bene, se l'insieme di cassetti \b non cambia\b0 , allora cambia per forza il contenuto. In questi casi, cambiano semplicemente i valori delle locazioni. Insomma, la foto del nostro sistema \'e8 un insieme di locazioni (funzioni con argomento). Una locazione, insomma, \'e8 la coppia (f, (v1, v2, ..., vn)), con f nome di funzione e (v1, v2, ..., vn) i suoi argomenti. f \'e8 il nome, i vari v i suoi argomenti. Di funzioni non se ne creano n\'e9 distruggono nell'esecuzione di una ASM. Al massimo vengono aggiornati i valori dei cassetti. In uno stato s, una locazione ha un valore: l'interpretazione della funzione nello stato. Data una locazione (cassetto), possiamo trovare il valore contenuto al suo interno. Se nella locazione loc ho al suo interno il valore a, allora f(v1, ..., vn) ) a. Quando aggiorno il valore di un cassetto, scrivo f(v1, ..., vn) := newval. Quindi, cambia il valore di loc. Quindi, stiamo sempre parlando di stati (insieme di cassetti con valore) e di passaggio di stato, ma non si aggiungono mai funzioni nuove n\'e9 se ne tolgono. Ricorda inoltre che il codice non verr\'e0 eseguito sequenzialmente: tutte le transizioni sono considerate contemporaneamente. Ora, tutto questo va descritto formalmente, e dobbiamo agganciarci alla logica. Quello che arriveremo a fare sar\'e0 descrivere modelli in termini di funzioni e regole che le aggiornano. partendo dalla logica, definiremo lo stato e le transizioni in modo pi\'f9 rigoroso.\par
Partiamo dal vocabolario sommatoria. Un vocabolario \'e8 una collezione finita di nomi di funzioni. Noi distinguere le funzioni tra dinamiche e statiche, a seconda che l'interpretazione del nome della funzione cambia o no da uno stato al successivo. Con "funzione" intendiamo il senso matematico, non informatico nel senso di procedure. Quindi, il vocabolario \'e8 un insieme di simboli (sintassi) a cuia ssociamo un significato (semantica). Dobbiamo insomma dare interpretazioni ai simboli. Se io fisso una volta per tutte il significato di un simbolo, allora quella \'e8 una funzione statica. Se invece a seconda dello stato il significato della funzione cambia (tipo una funzione 0-aria: studenti in aula prima vale 50, poi 0, \'e8 praticamente una variabile) allora sar\'e0 una funzione dinamica. Una variabile, appunto, \'e8 una funzione ad argomenti 0 che cambia nel tempo. Una costante stessa cosa, ma non cambia, quindi \'e8 una funzione statica. \par
Le funzioni statiche di ariet\'e0 0 sono dette costanti. Ci sono tre costanti che si possono usare in tutti i modelli: undef, true e false. L'undef \'e8 usato per poter garantire la totalit\'e0 delle funzioni (ci arriveremo dopo). Altre costanti sono costanti numeriche (i numeri) e altre user-defined. Le funzioni statiche possono comunque avere ariet\'e0 > 0, come +, -, AND e OR. Cio\'e8, l'interpretazione di queste funzioni \'e8 sempre la stessa, indipendentemente dallo stato. Anche qui, posso definire funzioni mie, tipo max(m,n) che \'e8 sempre statica: indipendentemente dal mio stato, il suo significato \'e8 sempre quello di restituirmi il massimo tra n e m.\par
Le funzioni dinamiche sono quelle che cambiano interpretazione di stato in stato. Quelle di ariet\'e0 0 sono praticamente variabili.\par
un esempio di vocabolario SIGMAbool dell'algebra booleana contiene due costanti, 0 e 1, una funzione unaria di nome - (negazione) e due funzioni binarie di nomi + e * (OR e AND). Tutte quelle elencate finora sono funzioni statiche.\par
Fissato un vocabolario, uno stato A del nostro vocabolario \'e8 un insieme non vuoto X, detto superuniverso di A, con le interpretazioni dei nomi delle funzioni di SIGMA. Quindi, posso definire uno stato partendo dal vocabolario e da un significato per i simboli del vocabolario. Se f \'e8 un nome di funzione n-aria di SIGMA, allora la sua interpretazione f^A \'e8 una funzione da X^n a X. Se c \'e8 una costante di SIGMA, allora la sua interpretazione c^A \'e8 un elemento d X.\par
Il superuniverso non pu\'f2 cambiare (per ora). Ma c'\'e8 una sorta di riserva da cui prendo cose che incrementano il dominio (lo vedremo dopo, complicato). Il superuniverso pu\'f2 essere visto come dominio.\par
Quello che scriviamo nei modelli non ha significato finch\'e9 non glielo diamo noi. Fino ad allora, il nostro modello \'e8 un semplice insieme freddo di simboli.\par
Se il mio stato ASM \'e8 un'algebra che definisco a partire dal vocabolario e l'interpretazione dei simboli su un superuniverso X che non cambia, sembra quasi che abbiamo funzioni e un solo dominio: X. Ma io devo poter distinguere diversi domini (tipo pc, sedie, umani...). Come faccio ad avere domini? Il superuniverso va pensato come partizionato in pezzi, sulla base di certe caratteristiche. Ogni partizione \'e8 per noi un dominio, perch\'e9 questo superuniverso \'e8 frammentato in pezzi, e ciascuno di loro \'e8 definito da un nome [funzione caratteristica!!!] cio\'e8, se X = 1,2,3,a,b,mario,pippo, allora il dominio Interi = \{1,2,3\} \'e8 anche una funzione che restituisce True quando x (l'argomento della funzione Interi() ) \'e8 1, 2 o 3, False altrimenti. Quindi, per noi un dominio \'e8 in realt\'e0 la SUA funzione caratteristica! Tutte queste funzioni/domini sono definite sul superuniverso X e restituiscono solo True oppure False. In tutto questo, il fatto che due funzioni restituiscano True per uno stesso elemento non ha importanza.\par
Quindi, dominio = set = universo. Col trucchetto appena descritto, possiamo modellare domini eteorenei nei nostri modelli. Ci sono domini predefiniti ovviamente: Interi, String, Bool, Real, etc.. Ovviamente possiamo anche noi stessi modellare i domini che ci interessano, sia "from scratch" sia partendo da un altro dominio. Scopriremo poi che il tool che useremo \'e8 basato su Java.\par
Vedremo inoltre che le funzioni possono essere ulteriormente classificate. In alcuni casi, il valore di una funzione proviene dall'esterno, mentre in altri casi siamo noi a dare valori alle funzioni, dall'interno insomma.\par
Recuperiamo, dalla logica, anche il concetto di termine. I termini di un vocabolario SIGMA sono espressioni sintattiche costruite in questo modo:\par
- le variabili sono termini\par
- le costanti sono termini\par
- se f \'e8 un simbolo di funzione n-aria di SIGMA e t1, ..., tn sono termini, allora f(t1, ..., tn) \'e8 un termine. \par
I termini di solito si denotano con r, s, t, mentre le variabili come x, y, z. Se un termine non contiene variabili, \'e8 anche detto chiuso. Ovvero, non pu\'f2 variare da uno stato all'altro. In caso contrario, il termine \'e8 aperto. Anche i termini non hanno significato finch\'e9 non gli do un significato/modello/semantica.\par
Cerchiamo ora di capire come scrivere le regole.\par
Cerchiamo di capire il concetto di regola di transizione. Uno stato \'e8 un'algebra, che parte da un vocabolario e un superuniverso. Passando da uno stato al successivo, ovvero, passando da un istante di tempo al successivo, le algebre cambiano. Dobbiamo capire come questi stati astratti vengono aggiornati, e per farlo dobbiamo capire le regole di transizione. Attenzione: non sono le classiche frecce, ma regole. Per costruirle, usiamo costruttori di regole, e avremo tante regole. Tutte le regole insieme sono chiamate "programma ASM". Vedremo che sta a noi scegliere se scrivere tante regole o una sola, e sar\'e0 la main rule che le far\'e0 scattare tutte quante.\par
Ricordiamoci che l'algebra alla fine non \'e8 altro che un insieme di funzioni, di cassetti. Quando passiamo da uno stato all'altro il loro contenuto cambia. Con l'update rule, possiamo cambiare i valori nei cassetti. Un'update rule pu\'f2 essere f(t1, ..., tn) := s (:= !!!!!, = significa invece equivalenza o uguaglianza). In questa regola, f \'e8 un nome di funzione dinamica n-aria di SIGMA, mentre t1, ..., tn e s sono termini di SIGMA. Se la funzione \'e8 0-aria, allora f \'e8 una variabile, e l'aggiornamento sar\'e0 del tipo c:=s. Vediamo ora dei costruttori di regola.\par
Costruttore if-then-else: si tratta di un costrutto di base che dice if phi then R else S. R e S sono entrambe update rule (o anche altre regole, in generale regole arbitrariamente complicate). Se la condizione phi, calcolata logicamente, \'e8 vera, allora si esegure R, altrimenti S.\par
Vediamo ora la classificazione delle funzioni ASM. Si classificano in Base e Derivate. Entrambe possono essere Statiche e Dinamiche. Quelle dinamiche sono: in (monitorate, sono l'input), controllate, condivise e out. Le "in" sono lette dalla macchina, ovvero lei le legge da un oracolo esterno. Sono cio\'e8 lette da M e scritte da env. Le "out" invece sono scritte da M e lette da env. "Controlled" sono invece lette e scritte da M, mentre le "shared" sono lette e scritte da M e env. Quindi, nel costruire i modelli, dobbiamo dichiarare la natura delle nostre funzioni. Una funzione controllata star\'e0 a sinistra di qualche aggiornamento, ovvero assegna a questa un valore, ma pu\'f2 stare anche a destra. [L'ambiente \'e8 tutto quello che non sta nel nostro sistema]. Le funzioni derivate (derived) sono invece simboli definiti da delle legge. L'idea \'e8 di aggiungere un nuovo simbolo al vocabolario, la cui regola che lo descrive la scelgo io. Il suo valore \'e8 preso da una regola applicata ad altre funzioni, e servono a rendere i modelli pi\'f9 leggibili. Ci sono diversi costruttori di regole nelle slide.\par
Skip Rule: skip, ovvero, non fare niente. E' una regola che con carta e penna non serve, ma vedremo che ci pu\'f2 tornare utile come placeholder. La useremo per parsare un certo modello ancora incompleto.\par
Let Rule: let x = r in R(x) (Se R ha parameri, realizza il passaggio per valore). Il significato \'e8: assegna il valore di t a x ed esegui R.\par
let x = f1(f2(f3(y))) in g(x) := 7 \'e8 lo stesso di g(f1(f2(f3(y)))) := 7.\par
Block Rule. La useremo spesso.\par
par\par
\tab R\par
\tab S\par
endpar\par
L'idea \'e8 che tutte le regole tra par e endpar sono eseguite in parallelo. La cosa non banale da digerire \'e8 che, davvero, NON C'E' SEQUENZIALITA'! E' molto simile a VHDL, dove dicevamo che in un processo l'assegnamento a segnali si fa una volta sola alla fine. Cio\'e8:\par
ipotesi: f(5) = 1\par
\tab f(5) := 2\par
\tab g(3) := f(5) --allo stato successivo, g(3) = 1, non 2, perch\'e9 le regole sono fatte in parallelo!\par
(Macro) Call Rule: ci serve per fare chiamate di funzione. Si scrive: r[t1, .., tn]. Se non ci sono argomenti, r[]. Significato. chiama r (una regola con parametri) con argomenti t1, ..., tn. E' proprio una chiamata di procedura. \par
Ancora, la main rule \'e8 il punto di partenza, ed \'e8 spesso una call rule. Conviene sempre cercare di capire prima questa regola, poi tutte le altre.\par
\par
Lezione 4 - 14/03/2022\par
Ricorda che uno stato \'e8 un insieme di locazioni, cio\'e8 funzioni con argomenti attuali (locazioni = cassetti).\par
La block rule serve come costrutto per mettere in parallelo delle regole. La conditional rule serve a eseguire una regola solo se una condizione \'e8 verificata. La let serve solo ad abbreviare una formula da usare in un contesto pi\'f9 ampio. La MacroCall rule serve invece a chiamare altre regole quando ci pare (funzione). Di fatto dichiariamo la regola da qualche parte e poi la richiamiamo. Oggi completiamo la panoramica delle regole con la Seq, la forall e la choose.\par
Seq: aggiunge sequenzialit\'e0 nelle ASM. E' una componente derivata nelle ASM. Forall: permette di applicare lo stesso comportamento a tutti gli elementi di un array. Choose: introduce non determinismo nelle ASM.\par
Sintassi Seq:\par
seq\par
\tab R\par
\tab S\par
endseq\par
Le regole all'interno possono essere tutte quelle che ti pare e usare costruttori di regola diversi. La differenza tra seq e modello di computazione normale nelle ASM, ovvero l'esecuzione in parallelo, \'e8 che il Seq introduce dei "microstati invisibili" tra due stati (quando passo da uno all'altro). \par
f(5) := 2\par
f(3) := f(5)\tab --allo stato successivo f(3) = 2\par
E' un costrutto pericoloso, nel senso che, se abbiamo troppi seq nel nostro programma, abbiamo sbagliato qualcosa nel modello che abbiamo formulato. In generale, quindi, NON LO USARE. A meno che non ci siano situazioni limite in cui ci servono variabili temporanee, come lo swap tra due variabili. Ne vedremo un esempio dopo. In generale, comunque, il seq deve servire solo a snellire il modello quando necessario, non come "shortcut". Un esempio di seq \'e8 il fattoriale.\par
Forall e choose hanno la stessa sintassi: forall/choose x with phi do R[x]. Nel forall, viene eseguita la regola R in parallelo per ogni x che soddisfa phi. Phi pu\'f2 anche ssere true se voglio eseguire un'operazione su tutti glie lementi del dominio. Con la choose, invece, scegliamo un elemento casuale che rispetta le condizioni phi e gli applichiamo la regola R. La choose sceglie sempre valori utili.\par
Una ASM allora la possiamo definire come una terna (SIGMA, A, R).\par
-Sigma: un vocabolario, dei simboli, una signature.\par
Uno stato iniziale A per SIGMA.\par
-Un insieme R di nomi di regole, con un nome di regola di ariet\'e0 zero, la cosiddetta "main rule", che \'e8 l'entry point per l'esecuzione della macchina, e una definizione di regola per ogni nome di regola. La semantica delle regole di transizione \'e8 data dall'insieme di tutti gli aggiornamenti.\par
Ci \'e8 sempre stato detto che in un'algebra le funzioni non vengono n\'e9 create n\'e9 distrutte, e che gli insiemi sono rappresentati come le loro rispettive funzioni caratteristiche. Spesso, nelle computazioni, abbiamo bisogno di dire per\'f2 che un certo dominio \'e8 stato esteso o contratto (come una pila). Dobbiamo quindi modellare l'aggiunta/rimozione di qualcosa che prima non c'era. Bene, questo \'e8 possibile con una nuova regola che ci permette di estendere un dominio. Per aumentare gli elementi dei domini, abbiamo la regola:\par
extend U with x [do] R\par
si tratta di una regola derivata da:\par
import x do\par
\tab U(x) := true seq R\par
"Scegli un elemento x da un insieme predefinito, chiamato "riserva", che \'e8 un insieme di simboli freschi. Togli x dalla riserva e aggingilo al superuniverso. Infine, esegui R." Vediamo sulle slide un esempio di operazioni sullo stack. (Nella rimozione, non facciamo garbage collection, semplicemente rendiamo l'elemento del dominio distaccato da ogni funzione, rendendolo quindi irraggiungibile).\par
Concetto di sensore: funzioni monitorate.\par
\par
Lezione 6 (alla 5\'b0 avevo scordato il portatile lol, ma ho preso appunti su carta) - 21/03/2022\par
ASMeta \'e8 statos viluppato con un approccio legato alla metamodellazione, pertanto \'e8 composto da quattro parti/linguaggi: strutturale, delle definizioni, deti termini e delle regole. Il primo ci da costrutti per costruire la struttura del modello. Il secondo per i domini, funzioni, invarianti e transizioni. E il resto non sono riuscito a trascriverlo. \par
Linguaggio strutturale: ci permette di definire delle parti fondamentali. Bisogna scrivere innanzitutto asm nomefile. La parola chiave asm pu\'f2 essere anche sostituita da "module" quando dobbiamo spezzare un modello grande in pezzi che magari si ripetono in modelli diversi, e che quindi vorremmo avere a disposizione in pi\'f9 modelli. Nei module per\'f2 non ci pu\'f2 essere main rule. Per importare librerie o file, si usa la keyword import. la StandardLibrary va sempre importata, perch\'e9 fornisce funzioni predefinite molto utili. poi c'\'e8 la signature, che contiene due parti: la dichiarazione dei domini e quella delle funzioni. C'\'e8 poi il body, ovvero le definitions: le defunizioni dei domini, delle funzioni, la dichiarazione delle regole e delle invarianti. Per i domini, nella definizione se ne da una segnatura, ovvero si dice la natura del dominio, mentre nella dichiarazione si esplicita il dominio vero e proprio. Quando scriviamo domain Second = \{0:59\}, la scrittura \{0:59\} \'e8 parte del linguaggio dei termini. Dopo il nome di doinio, va messo sempre un "domain term", cio\'e8 un dominio definito col linguaggio dei termini. I domini concreti statici sono gli unici che possono essere deifiniti. Per le funzioni, vale lo stesso finch\'e9 queste sono statiche e derivate. Per una regola, dichiarazione e definizione sono la stessa cosa. Nelle funzioni derivate, condenseremo un'espressione logico-numerica complessa che vogliamo condensare in una sola funzione. Il linguaggio dei termini si usa anche quando si d\'e0 la definizione di una funzione nel body. Le regole, invece, vengono dichiarate e definire usando il linguaggio delle regole. Nella parte di initialization, posso inizializzare solo domini concreti dinamici e funzioni dinamiche, non monitorate.\par
Una funzione senza argomenti si definisce nel codominio. Seq() \'e8 un costrutto della StandardLibrary per rappresentare liste anche di tuple. Bisogna sempre avere presente, nella definizione delle funzioni, il dominio e il codominio. \line I domini, in ASM, sono distinti in type-domain e concrete domain. Il simulatore \'e8 implementato in Java, quindi doveva assimilare la gestione degli insiemi di Java. Bene, quelli sono i type-domain, ovvero domini che corrispondono ai tipi predefiniti del linguaggio, come complessi, reali, interi, naturali, stringhe, char, boolean, rule e undef. Sono tutti nella StandardLibrary. A questi domini, si sommano gli structured domain, usati per costruire insiemi finiti, sequenze, bag, mappe e tuple a partire da altri domini. Si usano soprattutto sequenze. Poi ci sono gli enumerabili (ENUM), come Color = \{RED|,GREEN|.BLUE\}. Tutto il resto, ovvero domini a cui poi daremo una semantica, \'e8 un abstract domain.\line I concrete domain sono user defined e sottotipi dei type domain.\par
"n" si usa come suffisso per i naturali. I concrete domain sono insomma le definizioni che noi diamo ai domini "subsetof qualcosa". \line I domini astratti si dichiarano come abstract domain D. Questo, finch\'e9 non ci metto qualcosa dentro, rimane vuoto. Se dichiaro una funzione che ha come codoinio questo dominio astratto, lui non si lamenta, ma quando il modello viene eseguito il dominio deve avere qualche elemento all'interno per poter essere usato. \line Se d \'e8 un dominio, si possono scrivere:\line Prod(d1,d2,...,dn)\line Seq(d) -> non consente di avere ripetizioni e gli elementi sono in ordine.\line Powerset(d)\line Bag(d) -> consente di avere ripetizioni\line Map(d1,d2)\par
Ci sono poi convenzioni sul linguaggio delle definizioni, come $ davanti alle variabili. Per gli Enum, ci vogliono sempre setringhe con len >= 2 e fatta di solo lettere maiuscole. I domain iniziano per lettera maiuscola. le regole con r_. Le funzioni iniziano con lettere minuscole, che non siano "r_" o "inv_".\par
Le regole si scrivono:\par
rule R[(x1 in D1, ... xn in Dn)] = rule.\par
\par
isDef(f(x)) mi dice se quella funzione, per quel valore, \'e8 definita.\par
Il linguaggio dei termini comprende delle funzioni exist, exist unique e forall per i quantificatori.\par
Normalmente si leggono i modelli partendo dalla mainRule. Bisogna cercare di sfruttare le MacroCallRule per rendere la mainRule piccola e concisa.\par
choose $x in Domain with (condizione da verificare per scegliere quell'elemento) do (regola)\par
"Ottima osservazione": il let \'e8 bene usarlo quando vogliamo usare una monitorata pi\'f9 volte all'interno di una regola, e vogliamo che il suo valore sia consistente. \par
\par
Il simulatore, prima di darci l'update set all'esecuzione della main rule, controlla che nessun invariante venga violato. Controlla anche la consistenza degli aggiornamenti.\par
AsmEE ha opzioni di simulazione (preferences)\par
\par
Lezione 7 - 24/03/2022\par
I bag sono come insiemi ma possono avere elementi ripetuti all'interno. Le sequenze invece hanno un ordine. Una sequenza \'e8 come un set con un ordine.\par
Quando abbiamo bisogno di sapere se esiste una funzione sui set, basta guardare sulla standard library. Including ed excluding potevano essere funzioni utili della libreria standard per fare operazioni su set. including \'e8 una funzione che include un elemento in un dominio. Quindi, la funzione, inserisce un elemento in un dominio, ed \'e8 definita su una coppia: il primo elemento \'e8 un set, il secondo \'e8 l'elemento che voglio inserire. Excluding \'e8 l'opposto. Si poteva anche, senza usare queste funzioni, usare una funzione che marcava un elemento come usato o meno (yeah, that's my solution).\par
Tool visualizzatore: bv e sv. Sono due pattern che ci mettono a disposizione: uno strutturale e uno semantico. Il primo crea una rappresentazione grafica per le regole. le regole sono rappresentate o come rettangoli o come esagoni. La rappresentazione semantica invece non funziona sempre. Quello che cerca di fare infatti \'e8 cercare di rappresentare il modello come una macchina a stati. Dal modello, il tool cerca di capire se \'e8 possibile identificare lo stato partendo da un insieme di funzioni.\line Poi abbiamo "ma" (model advisor): funzionalit\'e0 che cerca di capire se il modello \'e8 di buona qualit\'e0. Come viene misurata? Su una serie di attributi che il modello ASM deve avere, insomma si tratta di qualit\'e0 che ogni modello ASM deve avere. Per ciascuno di questi attributi, per capire se il modello ha quell'attributo, viene definita una metapropriet\'e0. Si tratta di una serie di 7 metapropriet\'e0 (auto-definite) che corrispondono ad attributi di qualit\'e0 che il modello deve avere.\line 1) Non ci devono essere update inconsistenti.\line 2) ogni regola condizionale deve essere completa. Ovvero, controlla se ogni if \'e8 un if-then-else. Se questa propriet\'e0 non viene rispettata, non vuol dire che abbiamo sbagliato: basta aggiungere else skip laddove necessario. \line 3) ogni regola viene eseguita (non sto facendo overspecification).\line 4) non ci sono assegnamenti banali, ovvero che non comportano una modifica dello stato.\line 5) per ogni elemento e di un dominio, esiste sempre una locazione che prima o poi prender\'e0 quel valore e.\line 6) ogni funzione controllata prende i valori dal proprio codominio.\line 7) ogni locazione controllata (funzione controllata) \'e8 aggiornata e ogni locazione viene letta. Ovvero, ogni controlled viene, ad un certo punto, sia letta che scritta.\par
Di fatto ma cerca di garantire queste tre propriet\'e0: coerenza (non ci sono aggiornamenti inconsistenti, m1), completezza (m2 e m7, ovvero ogni comportamento del sistema \'e8 modellato in modo esplicito: le regole condizionali sono complete e le funzioni controllate sono effettivamente sia lette che scritte) e la minimalit\'e0 (niente overspecification, m3,m4,m5,m6 e solo funzioni encessarie, ovvero m7). \par
Queste sette propriet\'e0 sono poi tradotte in formule temporali: il model advisor infatti prende il modello, lo mappa in un modello del model checker e verifica se questo insieme di metapropriet\'e0 \'e8 verificato o no. Per poterlo usare dobbiamo soddisfare i limiti per cui un modello asm pu\'f2 essere mappato in un modello NuSMV e aver importato la libreria per la verifica delle propriet\'e0 temporali.\par
Parliamo ora di insiemi che contengono oggetti, in particolare specifiche con insiemi di questo tipo. Su ariel c'\'e8 l'esempio dell'ATM (ATM case study).\par
Nei modelli, dobbiamo sempre modellare con delle monitorate un evento esterno. Nell'esempio dell'ATM, abbiamo una monitored insertedCard: NumCard. Questa funzione rappresenta la carta messa in ingresso.\par
L'obiettivo nostro non \'e8 ottimizzare i modelli, ma rappresentare gli elementi del mondo reale nel modo migliore possibile. Al massimo voglio cercare la minimalit\'e0 del modello, ma non l'ottimizzazione. Se vogliamo avere uno stato conservato dal modello, bene usare una monitorata per prendere il valore dall'esterno e una controllata per conservare quel valore di input.\par
(Slide 5: prime forme di analisi)\line Ne vedremo due: controllo di invarianti e validazione tramite scenari. vediamo gli invarianti: un'invariante \'e8 un'espressione logica che deve valere sempre in tutti gli stati del modello. E' insomma un predicato espresso sulle locazioni e che deve essere sempre vero. L'invariante permette di escludere delle computazioni quando sono soggette a valori monitorati che manderebbero in tilt il funzionamento del sistema. Se un'invariante viene violata, la run viene abortita. Le ivarianti vengono scritte come:\line invariant over id_function, ..., id_rule: term. Solitamente le regole non si mettono, ma ci sono casi in cui lo si fa. term \'e8 una propriet\'e0 logica che deve valere, ovvero che restituir\'e0 true o false. \par
\par
Lezione 8 - 28/03/2022\par
Validazione tramite scenari - un secondo modo, dopo gli invarianti, di provare la correttezza dei nostri modelli. Con gli invarianti vogliamo escludere alcuni valori per le funzioni, mentre con gli scenari facciamo un'altra cosa. Abbiamo fatto varie simulazioni per testare i nostri modelli, ma abbiamo visto essere questo un procedimento lungo. Quindi, ASMETAL ci da modo di specificare uno scenario e vedere come si comporta il modello relativamente a questo scenario. Uno scenario non \'e8 altro che la descrizione di un possibile comportamento del sistema. Come si sceglie? Di solito ci vengono date direttive, anche se in generale dovremmo fare scenari per i casi limite. Oppure anche i casi significativi sono utili. In UML avevamo i diagrammi di sequenza, ovvero diagrammi che esprimono come tra diversi elementi del mio sistema ci sia uno scambio di messaggi. Bene, quelli erano praticamente scenari, analoghi a quelli che vedremo noi. Nei modelli formali, poter costruire scenari si lega alla possibilit\'e0 di avere un modello eseguibile. Noi, per scrivere scenari, useremo Avalla, un linguaggi specifico. \line Vediamo un esempio: partiamo da una gradica UML in cui abbiamo all'esterno un attore, che interagisce con un sistema composto da casi d'uso. L'attore ha una vista black box del sistema: lo vede dall'esterno, ma non ha accesso al codice. In ASM, abbiamo di nuovo la possibilit\'e0 di esprimere un attore UML come una entit\'e0 che vede il sistema come black box. Tutto ci\'f2 che pu\'f2 fare \'e8 passare valori al sistema (valori di input, quindi le monitored). Come fa per\'f2 a vedere l'output che il sistema esprimete all'ambiente, cio\'e8 lui? Con le out. Pertanto, un attore ASM ha a disposizione un set di monitored e un check out locations, cio\'e8, un insieme di funzioni di input e un modo per vedere l'output prodotto dal sistema. L'attore ASM pu\'f2 fare anche altre cose per\'f2. L'attore ASM eredita le funzionalit\'e0 dell'attore UML, e ha le capacit\'e0 descritte poco fa, ma pu\'f2 addirittura guardare lo stato interno della macchina. Quando facciamo testing, lo facciamo "grey-box", ovvero s\'ec, lanciamo dei casi di test sperando in un certo output, ma se qualcosa non va andiamo a vedere il codice per capire cosa \'e8 andato storto. Questo attore, con altri comandi, ha quindi accesso ad una vista gray-view del sistema. Pu\'f2 insomma fare check anche dello stato interno e degli invarianti. Allo stesso tempo, l'attore pu\'f2 eseguire pezzi di regole per sapere delle cose. Tipo, potremmoa vere bisogno di far partire uno scenario non dallo stato iniziale ma da uno stato intermedio. Chiamando le funzioni e regole che ci pare, possiamo raggiungere questo scopo. \par
Un attore deve essere in grado di:\line -dare valore alle monitorate e alle condivise\line -controllare i valori delle funzioni out\line -controllare lo stato e gli invarianti\line -chiedere l'esecuzione di una specifica regola di transizione\line La macchina, viceversa, deve fare un passo e rispondere agli input dell'utente.\par
Asm Validation Language (AValLa) \'e8 il nostro tool per fare questa roba. Vediamo le primitive di questo linguaggio:\line -Set: un comando per impostare la locazione di una monitorata.\line -Check: per inspezionare i valori esterni e quelli interni dello stato corrente.\line -Step: fai un passo\line -StepUntil: fai tanti passi fino a che non \'e8 vera una certa propriet\'e0.\line -Invariant:\line -Exec: esegui una regola.\par
La sintassi dei comandi sta nelle slide.\par
I validatori sono V, Vc e Va. V fa una validazione base: vediamo se questo scenario \'e8 valido. Va: fa la validazione mediante l'animatore. Se un check viene violato, me lo dice e si blocca. Vc fa la validazione con la coverage/copertura. \line Cosa succede quando lancio uno scenario? Lo scenario e la specifica vengono temporaneamente fusi e validati. Ad ogni passo, si pu\'f2 avere un pass o un fail (grazie a un check praticamente). \par
In uno scenario vanno sempre date tutte le monitorate quando vogliamo fare un passo. Le regole possono essere richiamate dal modello oppure essere scritta ex-novo con il linguaggio a cui siamo abituati. La exec dello scenario va e sostituire completamente il passo "normale" che verrebbe eseguito dalla main rule. Idea per evitare problemi con la choose: fai la choose nella main rule, che poi col valore scelto chiama una regola. Nello scenario, chiama una exec che imposta "forzatamente" il valore della choose semplicemente scavalcando la choose, e chiamando direttamente la regola che usa quel valore. Insomma, bisogna cercare di isolare il valore scelto dalla choose e scrivere delle regole che fanno una roba dopo che il valore \'e8 stato scelto: non devono essere loro stesse a sceglierlo.\par
I file devono essere .avalla come estensione.\par
Alcune cose sul validatore: quando organizziamo il nostro lavoro su questi file, \'e8 meglio non usare spazi (nelle cartelle del path del file). Per importare una specifica ASM si pu\'f2 scrivere load ./spec.asm. Inoltre, il validatore si ferma due passi (stati) dopo la fine della simulazione dello scenario. Nel primo, mi viene detto che result \'e8 true. E' una cosa che serve a lui per capire che la simulazione \'e8 andata bene. Il secondo lo fa per accorgersi che l'update set \'e8 vuoto, e quindi la simulazione deve terminare. \line Nel simulatore possiamo esportare in avalla uno scenario! Ce lo produce all'interno della console del simulatore. Bisogna poi fare cut-n-paste per\'f2. Per poter scrivere nella console del simulatore per\'f2, dobbiamo avere aperta la console del simulatore. Negli scenari sono utili anche i blocchi. Supponiamo di avere uno scenario che valida la parte iniziale del sistema. Poi per\'f2 raffiniamo il modello aggiungendo dettagli, ma vorremmo far vedere che lo scenario di prima funziona ancora. Possiamo riciclare blocchi di altri scenari in altri scenari. Per dichiarare un blocco, basta scrivere \i begin nomeBlocco \i0 e \i end\i0  tra le due parti di scenario che ci interessa riciclare. Per eseguire un blocco, basta scrivere \i execblock nome_file_scenario: nomeBlocco\i0 .\par
Es: per il tris, cerca di scrivere scenari modificano il codice (discorso choose).\par
Sluice gate: lascialo perdere.\par
\par
Lezione 9: 31/03/2022\par
10:30 - 12: 30 marted\'ec probabilmente ci sar\'e0 una lezione. Seconda settimana di giugno ci sar\'e0 l'esame.\line Oggi vedremo una soluzione al problema della choose negli scenari che funziona sempre. \par
6 - Composizione (ASM-multiagenti)\par
Finora abbiamo visto modelli dove avevamo specificato una sola main rule che diventa il programma di una mente che esegue il modello. L'agente, che esegue il modello, fa un passo della main rule (ovvero fa una serie di aggiornamenti, update rule) e controlla se vengono rotte delle invarianti. Se per\'f2 va tutto bene, l'algebra viene aggiornata allo stato successivo. In vari modelli per\'f2 ci serve poter modellare il concetto di tanti agenti/entit\'e0 che computano parallelamente. Le ASM supportano questo principio nella modelalzione. E' bene non confrontare i limiti del simulatore con la teoria, che di limiti non ne ha. Nella teoria, le ASM multiagente ci permettono di modellare un sistema distribuito. Questi agenti sono elementi che stanno in un insieme predefinito dell'algebra. L'algebra attinge infatti i suoi elementi da un superuniverso, che pu\'f2 partizionare in insiemi distinti. Una di queste partizioni \'e8 l'insieme degli agents. Ciascuno di questi agenti pu\'f2 compiere mosse proprie, e pu\'f2 avere una visione del sistema \i parziale\i0 , cio\'e8 non vede proprio tutto. In un sistema distribuito, i vari nodi collaborano, ma i singoli nodi difficilmente possono vedere tutto il sistema insieme (altrimenti non sarebbe distribuito). Dobbiamo poter riflettere questa cosa anche nei nostri modelli. pertanto ogni agente ha dei movimenti indipendenti dagli altri, ma questi movimenti possono essere anche sincroni o asincroni (qui il simulatore nostro inciampa un po'). Dobbiamo inoltre distringuere il concetto di stato globale del sistema dalla vista locale che un agente pu\'f2 avere. La vista globale \'e8 quella che abbiamo noi di tutti gli agenti. Quella locale \'e8 una proiezione dello stato globale, dal punto di vista di un agente. Ogni agente pu\'f2 essere creato dinamicamente, non devono per forza esistere subito. Vedremo esempi di agenti creati a runtime, e vedremo un meccanismo che permette di aggiungere agenti e associare a questo agente un comportamento. In termini di vista locale, un agente pu\'f2 eseguire un suo programma e ha accesso ad alcune locazioni. Volendo, possiamo immaginarci di avere un insieme di Agents (predefinito, non va creato, ma usato e basta): quando istanziamo un elemento di questo insieme, ereditiamo una serie di procedure e comportamenti standard. Ad ogni agente \'e8 associato un programma "Program", e a pi\'f9 agenti pu\'f2 essere associato lo stesso programma. Ogni agente ha una vista locale dello stato globale, che non \'e8 altro che la conoscenza di alcune lcoazioni.\line Due agenti, per condividere informazioni, possono usare delle funzioni con cui leggere e scrivere valori. Ovviamente questo ci porta al pericolo dell'inconsistenza: non deve accadere che due agenti accedano nello stesso istante a una risorsa condivisa. Il nostro modello deve modellare anche questo fenomeno: lo scheduling dell'accesso a una stessa risorsa. Vedremo problemi di accesso concorrente a livello di modellazione infatti.\par
Cominciamo a definire la vista/visione parziale di uno stato globale. Matematicamente, View(a,M) indica la vista dell'agente a dello stato globale di una ASM M. Ovvero, la funzione a due argomenti View, dato l'agente a e la ASM chiamata M, mi dice cosa vede a di M. Supponiamo che f sia una funzione globale, da A in B, e che un agente pu\'f2 vedere in maniera privata/personale (come se dovesse farne una copia). La funzione va estesa nel dominio, cos\'ec da tenere di conto anche dell'agente. f(self, x) denota la visione privata di f(x) dell'agente corrente self. Ovvero, Pippo potrebbe dire che f(5) = 7 e Pluto potrebbe dire che f(5) = 9, e entrambi hanno ragione, perch\'e9 ognuno si riferisce alla sua visione privata della funzione. Questo \'e8 utile perch\'e9 se Pippo e Pluto eseguono la stessa regola, io non devo scrivere un programma diverso per ogni agente, ma un solo programma che viene istanziato tante volte quanti sono gli agenti necessari (cio\'e8 quelli che devono eseguire quel programma).\par
Andiamo all'esecuzione. La grossa differenza che si ha quando si mandano in concorrenza pi\'f9 agenti, \'e8 il concetto che hanno questi di "eseguire un passo". Qui distinguiamo gli agenti sincroni da quelli asincroni. Quelli sincroni operano con lo stesso orologio, quindi per loro il tempo trascorre allo stesso modo. Quelli asincroni valutano il passaggio del tempo in modo diverso. Lo stato globale quindi non \'e8 facile da ricostruire a partire dagli agenti, perch\'e9 i diversi agenti potrebbero avere un diverso concetto di tempo: quando \'e8 definito lo stato corrente? Corrente in che senso? Lo stato globale \'e8 una combinazione dei vari stati locali dei nostri agenti. Qui abbiamo una divergenza tra le ASM distribuite nella teoria e il nostro simulatore. Noi possiamo avere solo ASM sincrone. Possiamo far fare un passo al sistema intero, non ai singoli agenti. MA dal punto di vista teorico esistono eccome agenti asincroni. Altri strumenti modellano gli agenti come automi distinti. Ad ogni istante, ne viene scelto uno in qualche modo, gli si fa fare un passo, e quindi tutto torna. Ma questo non calza col principio della computazione distribuita dove i vari nodi vengono eseguiti concorrentemente. \line Quindi, una multi-agent ASM \'e8 definita come un insieme di coppie (a, ASM(a)), dove a \'e8 un agente e ASM(a) \'e8 il suo programma.\line Possiamo scrivere asyncr asm ASM_name per specificare che la asm \'e8 asincrona (per\'f2 non \'e8 supportato questo meccanismo dal simulatore, quindi metterlo o non metterlo \'e8 uguale, non \'e8 supportato, ma potrebbe esserlo in futuro). Se si omette, vuol dire che la nostra ASM multi-agente \'e8 sincrona. Nel caso di ASM multiagente, si pu\'f2 definire l'header come:\line import m1(id_11, ..., id_1h1)\line etc..\par
per importare un agente, per\'f2, questo deve aver esportato la sua segnatura. Si possono esportare dichiarazioni di domini, funzioni, e cos\'ec via. L'import va fatta da dove \'e8 contenuta la main rule. Tutti gli altri moduli non hanno una main rule.\par
Vediamo il concetto di computazione in ambiente multi-agent. Definiamo quindi la computazione per ASM sincrone. Nella teoria, una multi-agent ASM con agenti sincroni ha una quasi-sequential run (la esegue) quando ha una sequenza di stati S_0, S_1, ..., S_n, dove ciascun stato S_i \'e8 ottenuto dal precedente S_i-1 eseguendo in parallelo le regole di tutti gli agenti. \line Nel caso delle ASM asincrone, dove gli agenti possono esecuire con clock diversi, gli step dei singoli agenti possono avere durate diverse. Una ASM multi-agent con agenti asincroni ha una run parzialmente ordinata, ossia un insieme parzialmente ordinato (M, <) di mosse m (una mossa \'e8 una applicazione di regole). Date le mosse, si dice che m1 < m2 vale se m1 \'e8 eseguita prima di m2. si tratta di un ordinamento parziale e non totale perch\'e9, in generale, dati due elementi a caso di questo insieme, si pu\'f2 avere che queste due mosse che ho preso non sono confrontabili: non so dire quale viene prima e quale dopo. Se vengono dallo stesso agente per\'f2 certo che posso dire chi viene prima e chi dopo. Ora, questo insieme delle mosse gode di tre propriet\'e0:\line 1) storia finita: ad un istante t, la sequenza di mosse che ha condotto dallo stato S_0 allo stato S_t \'e8 finita. Cio\'e8, ciascuna mossa ha solo un numero finito di predecessori. Cio\'e8, per ogni m appartenente a M, linsieme \{m' | m' < m\} \'e8 finito. Queste mosse m' non devono per forza appartenere allo stesso agente: se due agenti hanno la "stessa lunghezza di gamba", nell'insieme di mosse di uno posso avere alcune mosse dell'altro.\line 2) Sequenzialit\'e0 degli agenti: ogni agente opera in modo sequenziale. Se prendo l'insieme di mosse \{m | m appartiene ad M, a esegue m\} di ogni agente a appartenente ad Agent, questo \'e8 lineramente ordinato per < (totalmente ordinato). Ovvero, localmente ad un singolo agente, riesco a ordinare totalmente le sue mosse.\line 3) Coerenza. Prendiamo l'insieme delle mosse con la loro relazione. Consideriamo un segmento iniziale finito, ovvero un sottoinsieme delle mosse dove riesco a identificare il massimo. Con lui, posso confrontare tutti gli elementi dell'insieme/segmento. Sia sigma(X) lo stato associato ad X. sigma(X) \'e8 il risultato di tutte le mosse m in X. Ciascun segmento iniziale finito X ha uno stato associato sigma(X) che \'e8 il risultato dell'applicazione della mossa m nello stato sigma(X - \{m\}), per ogni elemento massimale m appartenente ad X. \line TLDR: se arrivato ad un certo punto, dopo tante mosse, ho tanti massimi non confrontabili, e li tolgo tutti tranne uno, non mi cambia nulla. \par
Vediamo degli esempi: Produttore-Consumatore e Filosifi a cena.\line Agent \'e8 come un abstract domain: finch\'e9 non lo popolo "manualemente", sar\'e0 vuoto, cio\'e8 non avr\'f2 agenti.\line Le inizializzazioni degli agenti si fanno nella default init.\line program(agent) \'e8 un costrutto che prende la regola associata a un agente e la esegue. Prende un agente come argomento e ne esegue il programma associato. \line Definizione agenti - istanziazione costanti degli agenti - dichiarazione programmi degli agenti - esecuzione nella main rule dei programmi = come creare agenti.\line Self \'e8 difficile averlo (nelle regole?) se non ho un comportamento condiviso in un contesto multi-agente.\par
Come si ovvia al problema della choose negli scenari? (Pensavi ci fossimo scordati eh volevi) Vediamo la morra cinese: c'\'e8 l'utente vs pc, e il pc fa una choose. La monitorata si setta col set. Anzich\'e9 isolare il parametro della choose, si pu\'f2 controllare lo stato risultante se la scelta non deterministica \'e8 di un tipo piuttosto che di un altro. Cio\'e8: controlled = qualcosa implies condizione.\par
\par
Lezione 10 - 04/04/2022\par
Abbiamo visto come utilizzare le ASM, la loro definizione teorica e simili. Ora per\'f2 introduciamo una metodologia usata quando bisogna gestire la specifica di requisiti presenti in grande quantit\'e0, ovvero il raffinamento dei modelli e modello ground. L'obiettivo delle ASM \'e8 garantire la possibilit\'e0 specificare modelli per sistemi. Ci servono un metodo di specifica e un processo di sviluppo. Il metodo sono le ASM. Queste ci permettono di modellare diversi modelli di computazione, come a singolo agente o multi agente e caratteristiche di non determinismo. Le ASM insomma ci fanno catturare il comportamento di un sistema come insieme di intelligenze o singola intelligenza. E questo \'e8 il metodo. Il metodo (le ASM) sono uno dei tre elementi che caratterizza il processo di modellazione che caratterizza le ASM. Il secondo concetto \'e8 quello di ground model, o modello base. Si tratta del modello costruito partendo dai requisiti, che deve avere alcune propriet\'e0. E' un modello di base. Il terzo concetto che caratterizza il processo di modellazione basato su ASM \'e8 il raffinamento di modelli. Questo consiste nel, partendo dal modello base, aggiungere dettagli fino a quando non ottengo un altro modello "raffinato". Procedendo cos\'ec, riuscir\'f2 ad includere tutti i requisiti che mi vengono posti. Per modelli infatti di grosse dimensioni, bisogna fare cos\'ec, perch\'e9 i requisiti possono essere veramente tanti. Scrivere un modello fin dall'inizio quando ci sono cos\'ec tanti requisiti \'e8 follia. I requisiti eprtanto sono organizzati in requisiti core, che vengono inizialmente formalizzati, e poi raffinati usando gli altri requisiti secondari. Questo raffinamento pu\'f2 seguire due strade: orizzontale e verticale. Quindi, avendo un modello e altri requisiti, possiamo raffinar eil modello. Orizzontale: tengo il modello cos\'ec com'\'e8 e ci aggiungo una nuova caratteristica, tipo la situazione dell'errore. Insomma, allargo il sistema. Verticale: Se avevo qualcosa di astratto, ad alto livello, ora lo raffino, lo dettaglio.\line Il processo di sviluppo parte dalla ASM ground, detta anche ASM 0, e dopo vari raffinamenti diverr\'e0 la ASM che volevamo, la ASM n. Col raffinamento riusciamo ad introdurre tutte le componenti architetturali, fare poi validazione dei modelli, verifica delle propriet\'e0 del modello, e infine documentazione. Il modello Ground gode di alcune propriet\'e0 che ora vedremo. Pu\'f2 essere non completo rispetto ai requisiti, innanzitutto. Un modello di questo tipo non ha ancora specificato tutti i requisiti in maniera dettagliata. Di per s\'e9, il modello ground non pu\'f2 essere completo rispetto ai requisiti. Se applichiamo questo processo di sviluppo al processo di sviluppo sw, questo modello ground diventa il contratto tra cliente e programmatore. Se usassimo UML, sarebbe l'insieme dei modelli UML. L'idea \'e8 quella di applicare questi metodi formali nel processo dis viluppo software dopotutto, pertanto usati cos\'ec possiamo avere un processo di sviluppo sw rigoroso, dove cio\'e8 posso poi fare verifica, testing etc.. Gli elementi di questo ground model (predicati, funzioni, trasformazioni...) corrispondono ad entit\'e0 del mondo reale. Tipo, filosofi, forchetta... Questo modello deve essere preciso (ha una base matematica), \'e8 flessibile (possiamo modificare le definizioni di funzioni), semplice e conciso. Il GM dovrebbe sempre essere pi\'f9 conciso e semplice possibile. Ho una funzione che non c'entra coi requisiti? Cerchiamo di toglierla. Deve essere anche corretto e completo. Corretto: rispetto ai requisiti che ho deciso di modellare, il mio modello deve rispecchiarli per bene. Completo: rispetto al livello di dettagli desiderato. Ad un certo livello di raffinamento, la completezza \'e8 relativa rispetto ad un certo insieme di dettagli. Validabile: deve essere eseguibile, senn\'f2 qualcosa non va. La maggiore difficolt\'e0 in questi livelli \'e8 trovare il giusto livello di astrazione: qual \'e8 il minimo set di requisiti che devo considerare per fare il mio modello ground? Cio\'e8 cerchiamo di togliere, almeno inizialmente, tutto quello che poi pu\'f2 essere derivato dai requisiti base.\line Ci sono una serie di domande a cui possiamo rispondere per cercare di generare il GM: quali sono gli agenti del sistema e quali relazioni intercorrono tra essi? Cio\'e8 bisogna capire se siamo in un contesto mono o multi agente. Quali sono gli stati del sistema? Cio\'e8 determinare la frontiera tra sistema e ambiente. Questo ci fa capire le funzioni monitorate, ovver\'f2 come l'ambiente interagisce col mio modello. Poi, quali sono gli stati del sistema? Normalmente avr\'f2 una funzione state che mi permetter\'e0 di evincere gli stati del sistema (questa cosa non sempre c'\'e8). Capito questo, si individuano le parti statiche, dinamiche, e si dividono le funzioni nelle categorie che conosciamo. Fissata la segnatura, si va alle transizioni. Queste mi specificano il comportamento del sistema. Se una transizione \'e8 condizionata, la modeller\'f2 come un if-then-else. Gli effetti delle transizioni dovranno inoltre essere aggiornamenti di locazioni. Supponiamo di avere un certo comportamento a seguito di alcune transizioni: cosa succede se queste condizioni non vengono verificate? Ovvero, cerchiamo di ragionare sull'else di una regola. Se non succede nulla, bella. Se invece succede qualcosa, facciamo attenzione. Se poi i requisiti specificano situazioni di errore, dobbiamo cercare di inglobare queste parti del sistema nel nostro modello.\line Si presta poi attenzione allo stato iniziale del sistema e sui suoi limiti. Controllare poi se ci sono condizioni di terminazione (che vanno espresse). Questa condizione sar\'e0 nella regola principale: se la condizione di terminazione \'e8 verificata, allora basta, termina. Verificare poi se la descrizione del sistema \'e8 completa e consistente.\line Vediamo l'esempio dello SluiceGate.\par
Ci sono delle tecniche che ci permettono di dimostrar eche un modello di livello n \'e8 corretto rispetto al livello n-1. Cio\'e8 devo dimostrare che il mio nuovo modello \'e8 un corretto raffinamento del precedente.\line Ogni modello che si dimostra essere un corretto raffinamento di quello precedente gode anche delle propriet\'e0 del modello sopra (ce le ho per buone insomma, yeah). \par
Principio di raffinamento: in altri contesti, quando si raffina, bisogna dimostrare che il raffinamento \'e8 corretto rispetto al precendente. Anche qui \'e8 la stessa cosa. In altri ambiti per\'f2 si usa il principio di sostituizione (black-box view): un utente non si accorge della diversit\'e0 del modello quando questo viene raffinato. L'aggiunta di monitorate rompe questo principio, nel caso delle ASM. Se raffinando aggiungo monitorate, il gioco cade insomma. C'\'e8 per\'f2 un modo di dimostrare che il passo di raffinamento \'e8 corretto: basta applicare il principio di commutativit\'e0 algebrica. Ogni stato di una ASM \'e8 un algebra, no? Bene, io ho, diciamo, due modelli, uno astratto e uno raffinato. Entrambi hanno uno stato iniziale e uno stato n/m. Il modello astratto fa un passo, e quello raffinato magari ne fa pi\'f9 di uno. Bene, il modello astratto fa un certo numero di passi (m), e quello raffinato ne fa un altro numero (n). Se prendo due stati che corrispondono tra loro, se la parte alta astratta si muove e in un certo numero di passia rriva allo stato S_i+m che corrisponde allo stato S_j+n della versione raffinata, allora sono a posto.\line Dobbiamo introdurre alcuni concetti: in questo schema di raffinamento, dobbiamo introdurre il concetto di stato raffinato. Poi il concetto di stati di interesse: tra tutti gli stati del modello astratto e raffinato, individuiamo delle coppie (Stato astratto, Stato raffinato) che vogliamo far combaciare/corrispondere. Quando dico che due stati si corrispondono, non posso dire che lo stato \'e8 uguale. Nello stato raffinato avr\'f2 pi\'f9 cose, pertanto l'algebra non \'e8 la stessa. Allora devo considerare delle locazioni di interesse, e dire in base a queste la corrispondenza astratto-raffinato. Insomma, stabilisco gli stati di interesse e le locazioni di interesse, e poi anche le relazioni di equivalenza dei dati tra le locazioni di interesse.\line Dobbiamo dividere le run (astratte e raffinate) in frammenti che mi garantiscano la commutativit\'e0. \line [La relazione di equivalenza pu\'f2 essere anche user-defined, \'e8 definita tra valori di locazione e la scelgo io, non \'e8 l'equivalenza tipo 3=3, non per forza almeno].\line Una volta stabilita la corrispondenza degli stati e la loro equivalenza, \'e8 psssibile asserire che M* \'e8 un corretto raffinamento di M sse ogni run raffinata- argh.\line Formalmente, devo dimostrare che per ogni run raffinata ne esiste una astratta, e una sequenza di sati che partono dallo stesso stato tali che S_ik = Stilde_jk per ogni k, e e entrambe le run sono infinite oppure sono entrambe finite e gli stati finali sono equivalenti.\line C'\'e8 anche il raffinamento stuttering di un modello astratto, dove per ogni stato astratto riesco a trovarne uno raffinato equivalente, o anzi, anche pi\'f9 di uno! In questo caso, ogni stato astratto \'e8 equivalente a (pi\'f9) stati raffinati. E' la tecnica che tipicamente si applica nei casi concreti. il "RefProver", un verificatore di raffinamento, fa proprio questa cosa, quando si cerca di raffinare un modello [Inoltre sembra che tutti gli stati raffinati conformi a uno astratto sono sequenziali].\line Nella pratica, quando raffiniamo, possiamo ritoccare segnature o regole. Nel raffinare la segnatura, possiamo aggiungere domini nuovi, o nuovi elementi in un dominio vecchio, o aggiungere funzioni. Quando lo facciamo, stiamo anche stabilendo la relazione tra stato raffinato e stato astratto, con le locazioni interessanti, la definizione di equivalenza etc..\line Raffinamento procedurale: raffiniamo le regole in base a nuovi elementi aggiunti, rendendole pi\'f9 complesse.\par
\par
Lezione 11 - 07/04/2022\par
Formalizzeremo un protocollo crittografico in ASM. Ci sono tanti casi di studio legati a problemi classici dell'ingegneria del software, e quello di oggi pu\'f2 essere particolarmente interessante. Molti studenti hanno infatti poi usato questo lavoro di specifica in una tesi in sicurezza, perch\'e9 questa specifica e analisi, che aiuta nella simulazione, permette di spiegare meglio questi algoritmi e mostrarne specifiche propriet\'e0. Il protocollo di oggi \'e8 quello di Needhan e Schroeder, usato in ambito crittografico. Altri esempi sono SSL, Kerberos, etc.. L'obiettivo di questi protocolli \'e8 cifrare e proteggere i messaggi passati. Quello che di solito si cerca di dimostrare \'e8 che i protocolli funzionano in ambienti "pericolosi". Quindi, non cerchiamo safety (cose cattive non si verificano), ma la security (vediamo i danni che l'ambiente causa al sistema, se l'ambiente \'e8 untrusted). Per farlo, dobbiamo modellare un qualcosa che sia malfidato, quindi qualcosa che fa parte DELL'ambiente, non qualcosa che si interfacci CON l'ambiente (monitored). Pertanto, se assimiliamo l'ambiente untrusted ad una spia, dobbiamo descrivere come ella si pu\'f2 comportare. Questa \'e8 la parte complicata: a seconda di quanto \'e8 forte questa spia possiamo garantire pi\'f9 o meno propriet\'e0. Se in un'analisi di protocollo non si ammette la modellazione della spia, l'analisi non serve a nulla. Di fatti ci interessa dimostrare che, in caso di presenza di ambiente untrusted, il nostro protocollo risulta comunque sicuro, e non ci sono informazioni sensibili che cadono in mano alla spia. Questa spia avr\'e0 alcune funzionalit\'e0, di solito analoghe a quelle del man in the middle. Quindi potr\'e0 conoscere (lo decidiamo noi) parti di messaggi, i messaggi interi o addiruttra forse la chiave. Per invece la parte della crittografia, bisogna modellare il fatto che un messaggio pu\'f2 essere crittato e decifrato, ma questa cosa va fatta in astratto: non possiamo modellare per intero la funzione crittografica. Inoltre, immaginiamo che un agente autenticato \'e8 "non compromesso" (le sue informazioni non sono note alla spia) se la spia non conosce la chiave privata. L'obiettivo del protocollo considerato \'e8 stabilire una mutua autenticazione tra due agenti A e B, e una "nonce" segreta comune, ovvero un pezzo di conoscenza comune ai due. \line Na \'e8 la nonce, A \'e8 il mittente, Kb \'e8 la chiave pubblica di B.\line Na \'e8 la nonce di A, Nb \'e8 la nonce di B, Ka \'e8 la chiave pubblica di A.\line Poi A manda un ultimo messaggio a B.\par
Il protocollo \'e8 suscettibile ad attacchi di tipo man in hte middle, e ci\'f2 \'e8 stato scoperto da un tizio che ha fatto un'analisi di tutte le possibili esecuzioni del protocollo (?). Cosa succede? Immaginando che A inizi una sessione di protocollo con un utente non onesto (E), E fa credere ad A di essere B e a B di essere A. In questo caso, il protocollo si rompe.\line I nonce sono informazioni private del mittente/destinatario.\line Questo \'e8 l'attacco di Lowe, che, dopo aver scoperto la falla, modifica il protocollo, aggiungendo al secondo messaggio l'identit\'e0 di B.\par
Il problema dell'analisi di protocolli \'e8 che \'e8 complicata, per una serie di ragioni. Si possono usare, ad esempio, dei metodi formali, per fare l'analisi, ma non sono proprio facilmente utilizzabili dal grande pubblico. Quindi, un promo problema \'e8 che questi tool non sono facili da utilizzare, e poi i meccanismi di verifica che ci stanno dietro non sono nemmeno loro facili. \par
genNonces: insieme di nonce gi\'e0 generate. \line Gli elementi di traffic sono terne sender-reciever-messaggio.\line readTraffic: mi da true se un certo elemento di traffico \'e8 gi\'e0 stato letto.\line MessageType: le tre tipologie di messaggi che ho nel protocollo.\par
Esercizio: modellare SSL. Va modellato anche il concetto di certificato.\par
Venerd\'ec 29 mattina altra lezione :(\par
Sarebbe alle 10.30\par
Vediamo il timer in ASMetal.\line Ci sono varie situazioni in cui abbiamo bisogno di modellare vincoli temporali in alcuni sistemi, del tipo: se sono una situazione e sono passati x secondi, cambia e fai qualcos'altro. Per poter applicare le ASM in questi contesti, bisogna applicare regole temporali. In particolare, modelleremo il tempo come una funzione monitorata. Infatti non ci interessa l'ora corrente, ma se \'e8 passata una certa quantit\'e0 di tempo. Anche in UML abbiamo questa esigenza ("after tot tempo"...), ma anche l\'ec non ci interessa l'istante di tempo corrente, quanto il fatto che, dopo un certo quantitativo di tempo, dobbiamo fare qualcosa. In realt\'e0 abbiamo gi\'e0 modellato noi stessi cose simili: con una monitorata integer, possiamo indicare il tempo corrente, oppure, con una monitorata timePassed (boolean), possiamo indicare se \'e8 passata una certa quantit\'e0 di tempo. Per tutti i casi, comunque, abbiamo una nuova libreria: TimeLibrary. \line Ha il dominio astratto Time Units (secondi, ms, etc..).\line Un dominio astratto Timer che gestisce il timer.\line Funzioni e regole per gestire i timer.\line Sulle slide un esempio della chiusa rivisitato.\par
window -> preferences -> asmeta -> simulator: meccanismo del tempo.\par
Si pu\'f2 andare indietro nel tempo! Ma la Professoressa non sa se ha senso come cosa lol.\par
\par
Lezione 12 - 11/04/2022\par
Vediamo gli esercizi.\line Bambini e Caramelle.\par
In generale, se scriviamo un if che non pensiamo abbia bisogno di un else, non dobbiamo scrivere else skip. Se davvero la macchina non fa niente quando quella guardia non viene rispettata, allora l'else pu\'f2 non essere modellato.\par
Vediamo ora gli scenari. Cosa si fa in caso di presenza di choose?\line Solito discorso: o controllo cosa succede per ogni possibile valore che la choose pu\'f2 assumere, o creo una regola che usa la choose che chiama, dopo aver scelto un valore, la vera e propria regola.\line Va bene fare tanti scenari brevi, dove per\'f2 faccio vedere alcune propriet\'e0. Anzich\'e9 mettere tre controlli in uno scenario, metti un controllo per ogni scenario, scrivendone 3.\line L'implies usato per aggirare la choose va bene finch\'e9 il dominio della choose \'e8 finito e comunque piccolo. La set viene usata per assegnare valori alle monitorate (che lui trasforma in controllate)\line Quindi, se abbiamo la choose: o facciamo l'implies se possibile, o lanciamo una sottoparte del modello facendo attenzione a "non dargli troppi scenari tutti iniseme". \par
Esercizi ASM multi-agenti.\line Sensore e sbarra (02-07-2013): nei sistemi multi-agente bisogna distinguere gli agenti dalle monitorate. Qui avevamo un controller, primo agente, e "la cosa comandata", il secondo agente. I sensori invece rappresentano ci\'f2 che l'ambiente comunica al sistema. I sensori non vanno MAI modellati come agenti.\line Meccanismo generale da usare dietro a is_car_present: abbiamo due agenti che devono comunicare. I sensori sono monitorati per l'intero sistema, e verranno acquisiti dalle due parti. Il controllante deve dire qualcosa al controllato, e questa cosa dobbiamo gestirla noi. Nel mio caso era una booleana is_car_present, e andava bene. Si tratta insomma di una variabile shared (che ASMetal gestisce come controllata) che uno scrive e un altro legge. La struttura del controllato \'e8 sempre if (shared) then...\line r_gate:\line if comando=questo then...\line if comando=quest'altro then...\par
Condizionatore: l'agente \'e8 chi controlla e chi \'e8 controllato. Abbiamo l'intelligenza che controlla il condizionatore (quindi la logica del leggere la temperatura dell'utente, accendere e spegnere il condizionatore...), mentre ora anche il condizionatore \'e8 un agente. Di solito, i sistemi controllati (CONTROLLATI) sono banali, hanno un solo stato. Se mi arriva il comando accenditi, allora stato = acceso. (Minchia una cazzata wtf).\line di solito "command" \'e8 un buon nome per il canale di comunicazione.\line In generale, in schemi controller-controlled, mandare in par le due regole degli agenti va bene. \line\line Processi (15-09-2011): la regione critica con i processi che possono stare in uno stato tra idle, entering, critical e exiting.\line Anche il semaforo \'e8 un agente! Ha stato verde o rosso e cambia a seconda del fatto che un processo prenda o meno la risorsa condivisa. \line Monitorata dall'insieme di process nei booleani. Ho insomma una monitorata per ogni processo che dice se quel processo \'e8 interessato ad entrare nella regione condivisa. Se \'e8 a true per il processo p, interested(p) = true e si va in entering state. \line altra monitorata: finished(process) -> boolean. Questa mi diceva che il processo aveva finito all'interno della regione critica. \line Di fatto le monitorate per entrare e uscire potevano essere usate per effettuare la comunicazione tra i processi e il semaforo.\par
Metropolitana (04-11-2014): in questo caso abbiamo controllante e controllato. il controllante da il comando di apertura, chiusura... e la metro controllata che passa dallo stato aperto, in apretura, chiuso, in chiusura, che risponde ai sensori.\par
\par
Lezione 13 - 21/04/2022\par
Logica temporale e model checker. Lasciamo un attimo da parte la asm ASMetal, e vediamo una aprte pi\'f9 teorica. libro di riferimento: logic in computer science, modelling and reasoning about systems, autori M.R.A. Ruth, M.D. Ryan.\line Nel mondo dei metodi formali, quando abbiamo un sistema di cui vogliamo provare delle propriet\'e0, abbiamo bisogno di un ambiente dove costruire il modello (lo abbiamo fatto con ASMetal). Ora per\'f2 il modello non saranno pi\'f9 le ASM, ma un automa (di kripke), ma in ogni caso, se dobbiamo provare delle propriet\'e0, abbiamo bisogno di un modo per modellare il sistema. Poi ci serve un linguaggio per scrivere le propriet\'e0 da dimostrare. E infine, ci serve un metodo/algoritmo per verificare che le propriet\'e0 siano rispettate dal sistema. Modello, linguaggio delle propriet\'e0 e metodo di verifica delle propriet\'e0 nel modello. Questo \'e8.\line Ora, l'idea \'e8: costruiamo un modello M che descrive il comportamento del sistema. Il modello lo scriveremo come automa di Kripke. Poi, le propriet\'e0 invece le scriviamo nel linguaggio della logica temporale. Questo linguaggio aggiungere degli operatori per modellare il tempo alla logica del primo ordine. Possiamo quindi dire che alcune cose accadranno nel futuro, ma non potremo dire cose che sono successe nel passato. Poi, dato il modello (automa di Kripke), e la propriet\'e0 phi scritta in logica temporale, scriveremo un algoritmo (lo studieremo) per dimostrare se la propriet\'e0 phi \'e8 vera o falsa rispetto al modello M. Alla fine di tutto, comunque, dovremo solo saper leggere gli automi di kripke (non scriverli dai requisiti), perch\'e9 tanto poi la verifica la faremo sempre in ASMetal. Infatti, la nostra ASM diventer\'e0 dietro le quinte un automa di kripke, che vedremo se soddisfa alcune propriet\'e0 phi tramine l'uso del model checker. Vedremo addirittura che le funzioni vengono mappate in variabili e cose pi\'f9 semplici. Still, dobbiamo sapere leggere questi modelli (di kripke). Le formule le scriveremo con la logica temporale, e sappi che la difficolt\'e0 \'e8 tradurre una espressione scritta in linguaggio naturale in logica temporale, non la logica temporale stessa.\par
Come mai si usa proprio la logica temporale? Perch\'e9 le logiche classiche ci fanno scrivere propriet\'e0 che valgono nel presente o nell'assoluto. Siccome il sistema evolve nel tempo spesso e volentieri, vogliamo poter esprimere come il sistema si evolve e che cosa garantisce il mio sistema se si evolve in un certo modo. Es: se giro tre volte la chiave, allora la porta si aprir\'e0. Queste cose non riusciamo a dirle con facilit\'e0 nella logica classica, perch\'e9 non ci permette di dire "oggi questo, domani quello". Di logiche temporali ce ne sono tante, e fanno parte di quelle modali, ovvero che hanno a che fare coi modi. Nel nostro caso, il modo \'e8 il tempo. Di queste logiche ce ne sono tante e cambia il modo in cui viene gestito il tempo. in particolare, si distinguono:\line LTL: linear-time logic. Qui il tempo \'e8 rappresentato come una successione di stati. La successione di stati rappresenta l'evoluzione del sistema.\line BTL: branching-time logic. Il tempo viene rappresentato come un albero, dove la radice \'e8 l'ora, l'adesso, i rami sono i possibili futuri. Insomma, se parto da un certo stato, il domani potrebbe avere una certa forma. Se avr\'e0 quella forma, allora il dopodomani potr\'e0 avere altre possibili forme, e cos\'ec via. Insomma, tutta la possibile computazione del mio sistema \'e8 un albero, un albero di possibilit\'e0. \line Un'altra distinzione delle logiche sta nel fatto che il tempo pu\'f2 essere rappresentato come continuo o discreto. Noi studieremo una \b logica branching-time discreta\b0 , la CTL, Computational Tree Logic. Quindi avremo alberi a tempi discreti. Le logiche continue sono molto pi\'f9 incasinate.\par
In questa logica CTL, cosa troviamo? Ebbeme, essa ci permetter\'e0 di scrivere propriet\'e0 temporali. Trattandosi di una logica branch, il modello del nostro sistema sar\'e0 un automa, e l'insieme degli stati in cui si pu\'f2 trovare il sistema verr\'e0 rappresentato da un albero, su cui prendono significato le formule che scriviamo. In particolare, potremo dire che, se oggi \'e8 cos\'ec, allora in un possibile domani \'e8 cos\'e0, ma anche che se oggi \'e8 cos\'ec, allora in qualunque domani si manifesti \'e8 sicuramente cos\'e0, etc..\par
Vedremo che le formule scritte secondo Kripke prenderanno forma e significato nell'albero. Come scriviamo le nostre formule in logica temporale? Si parte dalla logica proposizionale. Si parte da un insieme di lettere proposizionali o formule atomiche AP, del tipo \{p,q,r...\}. Possono solo essere vere o false, queste formule. Le formule CTL possono essere induttivamente definite come: T, F, una proposizione... (vedi slide, molto simile alla logica proposizionale comunque, eccetto per l'aggiunta di alcuni \i connettivi temporali\i0 ). \line Di fatto, le formule che scriviamo in questa logica, assumo significato nell'albero. Per cosa stanno A ed E? A = "always on the tree": questa cosa vale sempre, su ogni ramo. E = "exists at least on the tree": questa cosa vale per almeno un ramo. Si combinano, A ed E, con...\line -X: next state. AX ad esempio dice che per tutti i figli diretti dello stato corrente vale che...\line -F: some future state. AF: su tutti i rami, nel futuro (non necessariamente tra 1 passo, 2, 3... e pu\'f2 darsi anche che si verifiche a livelli diversi su rami diversi), varr\'e0 che...\line -G: all future states (globally). AG: su tutti i rami, globalmente, varr\'e0 che... (quindi vale su OGNI STATO dell'albero). EG: su un solo ramo/cammino, su TUTTO il ramo/cammino, vale che...\line -A[phi U phi]: deve valere una certa cosa, la prima phi, fino a che non vale l'altra, la seconda phi (U \'e8 until). E[phi U phi]: esiste un ramo...\line L'until pu\'f2 poi essere forte o debole, cio\'e8, quando la seconda cosa diventa vera, la seconda non lo \'e8 pi\'f9, oppure la seconda diventa vera ma anche la prima pu\'f2 esserla. \par
Oridnamento: gli operatori unari hanno priorit\'e0 pi\'f9 elevata di quelli unari (vincolano di pi\'f9). Seguono in ordine AND e OR a pari merito, poi ->, AU ed EU.\par
[\'e8 plausibile vedere in una formula A da solo: vuol dire che dopo c'\'e8 un U!]\par
Semantica CTL\par
Quando da un albero si passa a un solo cammino (LTL), rimangono solo (?) X, F e G, perch\'e9 tanto non ci sono multipli cammini, ma solo uno. \line Vediamo roa l'automa di Kripke.\line Un automa di kripke \'e8 una M costituita da (S, DELTA, I, L).\line S \'e8 l'insieme degli stati, DELTA (o ->) \'e8 la funzione di transizione tale per cui per ogni stato s deve esistere uno stato successivo s'. Questa propriet\'e0 \'e8 detta propriet\'e0 di serialit\'e0, e fa s\'ec che un automa di questo tipo non vada mai in deadlock. I \'e8 invece l'insieme degli stati iniziali, e infine abiamo una funzione di etichettature L: S -> 2^AP (formule iniziali di base, con la logica proposizionale, per poter descrivere le formule). Ogni stato infatti \'e8 costraddistinto da un sottoinsieme delle lettere proposizionali. 2^AP perch\'e9 \'e8 il powerset praticamente (anche senza praticamente), e le lettere presenti rappresentano i predicati veri in quello stato, quelle assenti rappresentano i predicati falsi in quello stato.\line Siccome l'albero rappresenta l'evoluzione del tempo, la propriet\'e0 di serielit\'e0 \'e8 necessaria in quanto il tempo non si pu\'f2 fermare: al pi\'f9, ad un certo punto, una certa propriet\'e0 rimarr\'e0 vera in eterno. Per questo, in un automa di Kripke, non ci sono stati finali: tutt'al pi\'f9 stati che rientrano in se stessi in eterno. \par
[G e F si riferiscono anche allo stato corrente (\'e8 pi\'f9 un "pu\'f2" nel caso della F)]\line [Il presente \'e8 contenuto nel futuro, sempre. Quindi una formula come AF p, se p ce l'ho nello stato corrente, \'e8 vera]\par
Vediamo la semantica dei connettivi CTL. Dato un modello M che \'e8 un automa di kripke della logica CTL, e dato uno stato S dell'insieme degli stati dell'automa, la formula \'e8 vera nella coppia macchina-stato. Data la coppia macchina e stato, una formula phi \'e8 soddisfatta quando...?\par
In A [phi1 U phi2], se abbiamo una sequenza phi1 -> phi1 -> phi1 phi2 -> phi1, la formula "termina", "si interessa" solo fino al passo phi1 phi2.\par
L'algoritmo di model checking gestisce solo not, and, false, AF, EU e EX, che possono essere ottenute mediante equivalenze tra formule, data una qualsiasi formula.\par
Le definizioni dei M, s soddisfa "formula" va data con la definizione chiara e matematica come nelle slide.\par
Le formule di riduzione vanno sapute, e vanno sapute anche le dimostrazioni di riduzione tra le formule. \par
\par
Lezione 14 - 28/04/2022\par
Oggi vedremo come questi sistemi di verifica possono essere usati nell'ambito della verifica di protocolli. Inoltre, tra qualche tempo, potremo partecipare all'attivit\'e0 di valutazione dell'usabilit\'e0 che fa parte dello sviluppo di questo sistema. Chi vuole pu\'f2 anche sostituire la prova di laboratorio con qualcosa di pi\'f9 significativo, che poi si pu\'f2 evolvere in parte di una tesi. Mario \'e8 al secondo anno di dottorato in informatica.\line Oggi parleremo di AProVer, tool che integra pi\'f9 lavori di tesi magistrali. Il problema principale che si vuole colmare \'e8: ci sono un sacco di telecomunicazioni di ogni tipo, e queste usano protocolli di sicurezza sviluppati magari ad hoc per l'applicazione particolare. Tutta l'area che il messaggio attraversa dovrebbe essere sicura. Tuttavia, non \'e8 vero che per tutti i protocolli si ha la sicurezza matematica che siano completamente sicuri. Vediamo alcuni elementi di questo contesto:\line -Principal: chi invia e riceve messaggi, e anche Eve.\line -Messaggi: i messaggi inviati secondo un certo formato.\line -Field: i campi dei messaggi.\line -Security Concept: ci\'f2 che costituisce la sicurezza del messaggio.\line Spesso si usa il testing come principale metodo per la ricerca della vulnerabilit\'e0. In verifica, per noi, esistono due modelli principali. Quello computazionale, dove abbiamo tutta la parte di analisi statistica per trovare correlazioni tra le chiavi e capire se il messaggio pu\'f2 essere rotto. Qui i messaggi sono messaggi binari, e le funzioni di cifrature producono altre sequenze di bit. L'avversario invece \'e8 una MdT deterministica, e per studiare gli attacchi si assume che Eve non riesca, oltre una certa probabilit\'e0, a rompere la cifratura. Solo i crittografi fanno uno studio di questo tipo, avendo le nozioni necessarie. L'altro modello, quello simbolico, \'e8 pi\'f9 semplice, e prevede un'astrazione. Le funzioi crittografiche sono raprpesentate come funzioni di simboli considerate black box, del tipo: dec(enc(x,y),y)=x. Non si danno informazioni sulla primitiva crittografica usata. Ora, come pu\'f2 dell'algebra essere utile per trovare vulnerabilit\'e0? Non solo pu\'f2 essere utile, ma anche intuitiva. Vediamo un "semplice" protocollo di inclusione di un nuovo dispositivo in una smart home. Si ha una prima parte di negoziazione del protocollo, poi uno scambio delle chiavi, e poi altre robe. Fatto tale scambio, si ha una chiave temporanea K_t.\par
Sviluppare protocolli per dispositivi IoT \'e8 difficile. Quello che si fa di solito \'e8 testing, analisi standard, etc.. Ma a volte non ci sono crittografi nel team. Il probelma \'e8: come possiamo aiutare queste persone a fare questi step "crittografici" senza avere troppo background di crittografia? Diciamo, sarebbe bello poter specificare i requisiti in modo formale. Si pu\'f2 ad esempio usare un diagramma di flusso. Oppure, usando questo tool, composto di Front-End, Linguaggio di validazione e Tool di verifica, si pu\'f2 anche costruire un modello del protocollo, che poi viene sottposoto a test di sicurezza mediante un tool di verifica.\par
\par
Lezione 15 - 29/04/2022\par
Oggi vedremo l'algoritmo di model checking, che ci permetter\'e0 di verificare se una formula temporale \'e8 vera o falsa. Una formula temporale pu\'f2 contenere diversi operatori, ma quando viene applicato il model checking, sulla formula si fanno delle semplificazioni, per esempio si possono avere solo NOT e AND, e anche EX, EU e AF, etc.. Il tutto si base sulle trasformazioni in formule equivalenti. Ci possono essere esercizi in cui \'e8 chiesto di dimostrare l'equivalenza di formule. Basta applicare la definizione dei connettivi comunque.\par
Come funziona l'algoritmo? Normalmente, abbiamo il nostro automa di kripke e una formula, e vogliamo, dato uno stato (iniziale), dimostrare se data M e s, phi \'e8 vera o falsa. Oppure possiamo dire: data la macchina e la formula, calcoliamo tutti gli stati a partire dai quali la formula \'e8 verificata. Cos\'ec facendo sapremo se la formula \'e8 vera partendo dall's specificato. \par
Labelling Algorithm. Prende in unput un modello e una formula e restituisce un insieme di stati s in cui la formula \'e8 soddisfatta. Il nostro algoritmo prender\'e0 l'automa e lo etichetter\'e0. L'automa infatti ha stati con proposizioni. L'algoritmo insomma etichetta i vari stati con le formule minimali. Inoltre, possiamo restringere il set di operatori CTL all'insieme composto da falso, NOT, AND, AF, EU e EX.\par
Prima dell'algoritmo, un'intuizione: guarda gli appunti.\par
\par
\par
\par
\fs44\par
}
 