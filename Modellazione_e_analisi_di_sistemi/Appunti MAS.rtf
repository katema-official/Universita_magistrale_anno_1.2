{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1040{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qc\f0\fs44\lang16 Modellazione e analisi di sistemi - Appunti\par

\pard\sa200\sl276\slmult1\qj\fs22 Lezione 1 - 28/02/2022\par
\par
Cosa studieremo in questo corso? In questo corso sono richieste competenze di un corso di logica, innanzitutto. Vediamo un attimo il perch\'e9 di questo corso all'interno di un percorso informatico (sicurezza lei dice, ma noi siamo della Gervasi Gang, GG). Abbiamo tutti fatto IS, e abbiamo affrontato il problema dell'attivit\'e0 di testing. Sviluppando software si seguono dei processi, e il software va realizzato in modo ingegneristico e deve avere la "reliability", ovvero affidabilit\'e0, cio\'e8 l'assenza di fallimenti in un lasso di tempo. Quindi, il sw deve comportarsi come vuole il cliente il pi\'f9 a lungo possibile. Se il sw devia dai requisiti, male, quello \'e8 un malfunzionamento. Se per\'f2 non si verificano per un po' di tempo, il sw \'e8 affidabile. Ma ancora meglio sarebbe avere un sw corretto, cio\'e8 che SEMPRE e COMUNQUE si comporta nel modo giusto, il sw. Queste qualit\'e0 vanno dimostrate, e come facciamo a dire che un sw \'e8 affidabile? Normalmente, molto testing. Si tratta di un'attivit\'e0 dove il sw viene esposto a una serie di scenari di esecuzione. Se mostra un malfunzionamento, cio\'e8 fa una cosa diversa da quella che mi aspetto, allora c'\'e8 un bug, e bisogna correggerlo. Fatto ci\'f2, di nuovo testing. Tuttavia \'e8 matematicamente dimostrato che il sw non pu\'f2 essere testato su tutti i possibili input. Quindi il sw viene rilasciato come affidabile, ma ci\'f2 non vuol dire che non esista uno scenario che non dimostra malfunzionamenti, perch\'e9 magari uno scenario negativo io non l'ho beccato. Sarebbe bellissimo dimostrare la correttezza del sw. Come si fa? Con strumenti avanzati e time consuming, ma appunto, non \'e8 banale impiegarli. Ci sono state, comunque, 10 situazioni di programmi con problemi software gravi che non erano stati trovati durante la validazione (testing). Alcuni esempi di fallimenti:\par
The Mats Climate Orbiter Catastrophe: orbita che non arriva su marte ma esplode prima dell'atterraggio in quanto, parte del sw che faceva funzionare la navicella, \'e8 stato commissionato ad un partner inglese che lo ha sviluppato usando i piedi come unit\'e0 di misura, e non il sistema metrico decimale. Quando tutto \'e8 stato messo insieme, non funzionava.\par
Ariane 5 Explosion: razzo che esplode mentre parte. Parte del sw dell'Ariane 4 veniva riciclato, ma i motori non erano "a conoscenza" del fatto che era cambiato il contesto.\par
Hole in the Ozone: della Nasa. Questo buco non \'e8 stato rilevato per tanti anni perch\'e9 la misurazione dell'ozono veniva misurata all'interno di un certo range di misurazione, ma il problema veniva evidenziato solo se si misuravano valori al di fuori di questo range.\par
Deadly Radiation therapy - Therac 25: sistema per la radioterapia, per curare i tumori. Ma per un problema sw le persone venivano sottoposte a radiazioni 100 volte superiori a quelle preventivate. Per un problema software, molte persone sono morte.\par
Il problema insomma \'e8 che abbiamo problemi safety-critical. Quindi riguardano la sicurezza, ma nel senso che il sw quando funziona non causa "cose cattive" all'ambiente (ogni sw \'e8 immperso in un ambiente, sia che si tratti di un ambiente fisico o umano). Questa era la sefety. La security invece \'e8 quando \'e8 l'ambiete a creare problemi al sistema. L'ambiente \'e8 vulnerabile, e quindi anche il sistema lo \'e8. Quando parliamo di sicurezza qui, intendiamo safety. I sistemi allora li distinguiamo tra safety critical e security critical. i primi sono tali per cui un malfunzionamento pu\'f2 avere conseguenze negative per le persone. Nello standard IEEE, \'e8 evidenziato che nel processo di sviluppo di sw medico, ci deve essere una fase di verifica (5.5). Ci sono vari enti predisposti, nel mondo, che richiedono una documentazione piena di evidenze e prove tali da provare che il sw sia sicuro. La fase di verifica, oltre a quella di testing, \'e8 necessaria. A dicembre del 2021, sono stare rilasciate patch di sicurezza per Windows. Pi\'f9 di 60 vulnerabilit\'e0 sono state corrette (spoofing, DoS, Elevation of Privilege, etc.). \par
Esistono persino modelli di sviluppo software security-critical (Capability Maturity Model Integration), che distingue verifica da testing. Quindi un prodotto buono deve essere safety e security critical. Per fare ci\'f2, serve la verifica. In questo corso vedremo come approcciarci al problema di verifica (on \'e8 testing o validazione). E' una attivit\'e0 human-intensive e richiede molte pi\'f9 skill. Noi vogliamo affrontare problemi di verifica per la safety.\par
Quindi, che faremo in questo corso? Presenteremo le tecniche per la modellazione everifica formale di sistemi hw/sw. hw/sw sono sistemi embedded, cio\'e8 hw che si interfaccia col sw. Dovremo fare modellazione e verifica formale insomma. Pensiamo al testing: se non ho il sw, non riesco a fare testing. Anche qui ci serve un manufatto su cui fare verifica: si tratta dei \b modelli. \b0 Useremo i linguaggi di specifica per scrivere modelli. Pensali come lingue con cui traduciamo i requisiti in qualcosa che tutti possiamo comprendere. Poi abbiamo bisogno di fondamenti teorici e metodologie di analisi. Quindi, linguaggi di specifica, come usarli, come fare attivit\'e0 di verifica e come usare strumenti automatici.\par
Impareremo due categorie di linguaggi di specifica: uno sugli automi e uno pi\'f9 simile alla logica (logica temporale).\par
Come analisi, distingueremo tra validazione e verifica (quest'ultima pi\'f9 forte). Come linguaggi ne vedremo due, uno basato sugli automi e uno sulla logica temporale. In un caso, modello il sistema come macchina che esegue. Nell'altro, si modella il sistema sulla base di propriet\'e0 che devono essere soddisfatte. Sugli automi, ripasseremo velocemente Abstract State Machine, un tipo particoalre di automa. Useremo anche un ambiente che ne permette la scrittura di scenari, verifica, etc.. Questi due mega-argomenti dei linguaggi poi si fonderanno insieme: avremo l'automa, le propriet\'e0 da verificare e i tool che verificano automaticamente.\par
Il tool che useremo sar\'e0 NuSMV, per scrivere le propriet\'e0. Faremo model checking e specificheremo propriet\'e0, tra cui: di raggiungibilit\'e0, di safety, di liveness, di fairness e assenza di deadlock. Liveness vuol dire che se un client chiede un servizio a un server, questo prima o poi glielo concede. Per garantire che una propriet\'e0 \'e8 vera, il sistema deve cercare di dimostrare quella propriet\'e0 in tutte le configurazioni in cui si pu\'f2 trovare. C'\'e8 anche, nei model checker, il problema della state explosion (non c'\'e8 abbastanza memoria per dimostrare tutto). Si pu\'f2 risolvere tagliando una parte del modello.\par
Dove studiare?\par
Abstract State Machines: a method for high-level system degind and analysis\par
Logic in Computer Science: modelling and reasoning about systems (2nd edition, 2004)\par
System and Software Verification model-checking techniques and tools\par
Software Reliability methods (per dopo il corso)\par
Esame: scritto e prova pratica. Domande e esercizi. La prova di laboratorio consiste nel dimostrare di saper usare l'ambiente attorno alle ASM. La prova scritta sono domande o esercizi.\par
\par
Cosa sono i metodi formali?\par
Si tratta di notazioni rigorose. Quando voglio esprimere in una logica normale "sto facendo lezione e c'\'e8 il sole", io sintentizzo le proposizioni (verbo, soggetto e complemento) con una lettera proposizionale e le unisco con operatori logici. Questo crea univocit\'e0 e ammazza l'ambiguit\'e0. Descriviamo insomma il nostro sistema in termini rigorosi e matematici, che ha simboli e significato (sintassi e semantica) [P and Q \'e8 un \b termine\b0 ]. Tutti i linguaggi avranno una notazione e un significato, che dobbiamo conoscere per costruire un modello, che descrive un sistema che fa calcoli. Ora, non bisogna essere per forza dei logici o matematici per fare cio\'f2: basta abituarsi a usare un nuovo linguaggio, come se fosse un linguaggio di programmazione. Ci sono poi tecniche per analizzare sistemi, che hanno un fondamento matematico. Ci sono insomma regole di dimostrazione che mi permettono di trasformare un predicato in un T o F. E lo posso fare perch\'e9 il mio modello supporta questo tipo di approccio. Insomma, ogni metodo formale \'e8 accompagnato da un metodo di verifica. Ora, modellare implica astrarre: cerchiamo di astrarre i dettagli dai requisiti per estrarre il vero comportamento del sistema, quello che davvero ci interessa. [UML non \'e8 un modello formale, altrimenti avrebbe accantoa  se approcci o tecniche per fare analisi, che invece non ha]. I vantaggi nell'uso dei metodi formali sono che possiamo descrivere il sistema in modo non ambiguo e univoco. Tutti insomma interpretiamo i requisiti allo stesso modo. Ogni modello inoltre va provato essere corretto, e abbiamo tecniche per farlo. Scrivendo dei modelli potremmo introdurre errori, ma poi possiamo trovarli grazie a questi strumenti e modificare il modello o i requisiti. A volte il modello va bene rispetto ai requisiti, ma dobbiamo cambiare i requisiti.\par
Quindi, scriviamo modelli con metodi formali: ma quanti metodi formali ci sono? Tantissimi. Non \'e8 come UML (unified... \'e8 uno standard aziendale), non ci sono standard. Ci\'f2 nonostante, questi formalismi possiamo dividerli in due categorie:\par
FORMALISMI OPERAZIONALI: descriviamo la macchina come un oggetto che computa. Mi dice come fare qualcosa per raggiungere lo scopo. Abbiamo: Abstract State machines, B method, Z method, SCR (Software Cost Reduction), Reti di Petri. Sono utili se vogliamo seguire la computazione del sistema, l'evoluzione insomma. Utili per la validazione.\par
FORMALISMI OPERAZIONALI: descriviamo un sistema in termini di propriet\'e0 che il sistema deve rispettare. Non mi dice come fare, mi dice cosa voglio. Abbiamo: Logica Temporale, Trio, Algebre dei processi. Ci servono per capire le propriet\'e0 che vogliamo soddisfare. Utili per la verifica.\par
Validazione: simile al testing (anzi, il testing \'e8 una forma di validazione). Il sistema soddisfa i requisiti specificati dal cliente.\par
Verifica: processo di valutare un sistema o una componente per determinare se i prodotti di una data fase di sviluppo sodisfano le propriet\'e0 imposte allo stato di tale fase. Si fa con dimostrazione di propriet\'e0, che di solito vengono effettuate mediante theorem prover e model checker. Model Checker: Modello + propriet\'e0 in pasto a una macchina = verifica, controesempio o memory exceeded. Theorem Prover: Modello + propriet\'e0 in pasto a una macchina, ma "tengo la mano" al dimostratore. L'utente insomma deve intervenire. Spesso con un theorem prover si arriva a un "dunque": siamo noi a dimostrare, quindi scegliamo un ramo di dimostrazione, e se ci porta a errori, possiamo fare backtracking. Noi faremo il model checker. [corso di Metodi Formali per fare anche theorem prover].\par
Cattivi preconcetti: la gente spesso diffida dall'usare i metodi formali, perch\'e9 pensa siano strettamente usati dai matematici. Inoltre si pensa che il processo di verifica sia soggetto ad errori: \'e8 vero, ma se non lo fai non hai la certificazione. Usare metodi formali, inoltre, rallenta lo sviluppo, ma se poi il prodotto \'e8 anche verificato posso provarne la correttezza, e quindi l'affidabilit\'e0 (no bug). \par
Esagerazioni: c'\'e8 chi pensa che la verifica formale sia il top che si pu\'f2 fare. Beh attenzione, perch\'e9 se io provo propriet\'e0 su un modello sbagliato, io non ho fatto niente praticamente. Insomma, non basta un modello e delle propriet\'e0 da provare. I modelli non sempre catturano i requisiti, bisogna fare attenzione. Poi, si dice anche che con la verifica il sw \'e8 sicuro (safety). In realt\'e0 per la complessit\'e0 odierna dei sw non si pu\'f2 avere la prova che l'intero sw sia corretto. Possiamo garantire l'assenza di fallimenti solo su piccoli pezzi del sistema, per l'intero \'e8 follia. Infine, si dice che il testing \'e8 il solo metodo usato nella pratica dalle industrie. Non \'e8 vero, anche la NASA lavora ai metodi formali, quindi sono importanti ANCHE loro.\par
Ebbene, impareremo: processo, come scrivere i modelli. La notazione appropriata, cio\'e8 ASM e Logica temporale. Infine i tools, ASMETA (ASM) e NuSVM (model checker e propriet\'e0 temporali). Ci saranno esercitazioni durante le lezioni di teoria. La prossima volta, ripasseremo le ASM. Le ASM sono un po' diverse dall SM che conosco: scriveremo praticamente un programma, non un diagramma. \par
\par
Lezione 2 - 07/03/2022\par
Automi per la specifica di sistemi (ripasso).\par
Logica proposizionale e dei predicati -> da ripassare (l'ho gi\'e0 quasi finito di fare).\par
La scorsa volta abbiamo visto che studieremo due formalismi utili a modellare e poi fare analisi su questi modelli. Il primo modello sono le ASM, e riprendono gli automi, e il secondo \'e8 la logica temporale. Entrambi questi modelli vanno basati sul concetto di automi. I nostri formalismi modellano un sistema, e si basano sul concetto di stato come istantanea di un sistema e il passaggio da uno stato al successivo mediante una transizione. Gli automi nascono come primo esempio di macchine capaci di riconoscere linguaggi, ma in generale vengono usati per modellare i sistemi. Prima di vedere i formalismi che useremo, ripassiamo gli automi. Questo concetto di automa infatti \'e8 nella pratica molto usato per fare uno sketch di un sistema che poi andr\'e0 implementato.\par
Un automa \'e8 matematicamente definito come una tupla di ingredienti:\par
-S, l'insieme degli stati, che sono in numero finito.\par
-I, insieme finito di eventi di input.\par
-sigma: S x I -> S, che \'e8 la funzione di transizione.\par
Ovvero, se sono in uncerto stato e applico un certo input, vado in uno stato successivo. Si rappresenta graficamente mediante un disegno dove gli stati sono dei cerchi e le transizioni (della funzione di transizione) sono delle frecce. Se vogliamo segnare uno stato iniziale, mettiamo una freccia che entra nello stato iniziale e che proviene dal "niente". Queste sono le macchine "di base", cio\'e8 che rispondono solo agli input. Vorremmo per\'f2 anche automi che cambiano l'ambiente, ma questo formalismo \'e8 troppo semplice per farlo.\par
Estensioni: macchine di Mealy. Le transizioni sono tuple del tipo (stato di partenza, input, output, stato di arrivo). Ovvero, dato uno stato e un input, va in un altro stato esponendo l'output sulla transizione. In una transizione, si scrive input/output per specificare che, a fronte dell'evento di input verificatosi, non solo si cambia di stato (basta seguire la direzione della freccia), ma si verifica anche un'azione rappresentata dall'output.\par
Tuttavia, io, con questo formalismo, non posso modellare macchine che, ad esmepio, mi scambiano monete. Tipo, immetto 10 monete da 10 cents e ricevo una moneta da un euro. Si tratta s\'ec di una macchina che ha input e output, ma che ha bisogno di ricordarsi delle cose. Le amcchine di Mealy non hanno memoria insomma. \par
L'estensione successiva \'e8 quindi quella della macchine a stati finiti estese. La transizione \'e8 ora una tupla (stato di partenza, input, output, guardia sulla memoria, azione di aggiornamento della memoria, stato di arrivo). La rappresentazione "a grafo" \'e8 come prima, ma abbiamo [coin=1] per le guardie, seguite dalle azioni del tipo "coin:=0". In pratica: se avviene un certo input e la guardia \'e8 vera, compio l'azione, emetto l'output e passo allo stato d'arrivo. Bisogna fare attenzione nelle guardie, perch\'e9 potremmo generare automi deterministici o non deterministici. Da notare come stiamo aggiungendo informazioni sulle transizioni. Un'osservazione: glis tati sono sempre cose semplici. Hanno solo un nome che raprpesenta la configurazione del sistema in un certo momento. Quello che non si riesce a fare con queste macchine sono i Sistemi Distribuiti. Immaginiamo un sistema produttore-consumatore. Potrei modellarlo con queste macchine, ma il numero di transizione esploderebbe. Perch\'e9 in uno stato devo tenere conto di cosa c'\'e8 nel consumatore, nel produttore e nel magazzino (?). Il passo successivo \'e8 quindi quello di definire le macchine di comunicazione.\par
Nelle macchine di comunicazione, ho:\par
-Una coppia (C,P), con C che sono i canali usati dai P processi per passarsi informazioni.\par
Dobbiamo immaginarci di avere tanti pezzi che comunicano tra di loro e possono anche comunicare con l'ambiente.\par
-Transizioni che sono: (s, c?i, s'), dove un pezzo legge informazioni da un canale (legge l'input i), (s, c!o, s'), dove invece si scrive su un canale l'output o e si passa a un altro stato. (s, null, s') per indicare che c'\'e8 stata una transizione da uno stato all'altro in un pezzo del sistema, ma non ha effetto sul canale.\par
E' arrivato poi UML con i suoi diagrammi, tra cui diagrammi per le amcchine di stato. Viene modellata come:\par
-Stati che hanno un nome e azioni di ingresso, l'attivit\'e0 che si compie mentre si \'e8 in quello stato, di uscita e eventi che, sulla base di alcune condizioni, compie azioni.\par
-Le transizioni anch'esse hanno un evento (l'input), una condizione (eventualmente) e un'azione.\par
UML cattura le macchine per Stati Finiti dividendo lo spazio in regioni parallele, dove ciascuna di esse ha una FSM che fa il suo lavoro e volendo comunica con le altre. In UML, la lettura di input \'e8 segnata come <<signal>>.\par
Ma la storia degli automi non finisce qua. Le ASM che studieremo sono un esempio di automa. Dobbiamo capire che il sistema ha una configurazione, una istantanea, che \'e8 lo stato, e transizioni che modificano lo stato. Tuttavia, per noi, questo stato che fino ad ora aveva semplicemente un nome, per noi sar\'e0 pieno di informazioni. Dopo pasqua vedremo anche gli automi di Kripke, dove lo stato \'e8 etichettato da lettere proposizionali. Lo stato, in questo caso, ci dice pi\'f9 che altro cosa \'e8 vero e cosa no in un certo stato (quale propriet\'e0 \'e8 valida in questo momento?).\par
\par
ASM\par
Le Abstract State Machines sono FSM cons"stati generalizzati", ovvero: mentre, finora, lo stato era uno stato cosiddetto "unstructured", ovvero dove non aveva una struttura se non per il nome, da ora in poi glis tati saranno strutturati. Lo stato \'e8 sempre modellato con un tondino (anche se poi lasceremo cadere la notazione grafica), ma in realt\'e0 per noi queste ASM saranno una sorta di pseudo-codifica. Useremo, per scrivere queste SM, un linguaggio di specifica. La principale differenza rispetto alle FSM \'e8 che questi stati sono strutturati. Ma cosa vuol dire? Viuol dire che lo stato diventa un'algebra, o "multi-sorted first-order structures". Io ad esempio voglio modellare un orologio che, in base al tempo corrente, visualizza il tempo in modo distreto ogni delta time. Quindi ho un orologio che, in base al tempo corrente, mi permette di vedere il tempo non in modo continuo ma a interalli di tempo (tipo ogni 5 secondi). Quali informazioni mi modelleranno questo fenomeno? Gli ingredienti che useremo per modellare li prendiamo dalla matematica. Cos'\'e8 un'algebra? Un insieme di simboli che hanno un'interpretazione. Nel nostro esempio, abbiamo la variabile CurrTime di tipo reale per ricordarci del tempo. La difficolt\'e0 di usare queste SM sar\'e0 usare la matematica per catturare quello che vogliamo dire. Poi abbiamo bisogno di qualcosa in cui mettere il tempo da visualizzare: DisplayTime, reale. Poi qualcosa che ci dica ogni quanto il tempo deve aggiornarsi: Delta, un reale (costante). Infine, una funzione + che va da Real x Real -> Real. Queste informazioni sono variabili, costanti. Tutte queste cose insieme costituiscono la mia algebra. Le variabili sono di fatto funzioni 0-arie.\par
Quindi, rappresentiamo lo stato attraverso un'algebra, con insiemi e funzioni. Gli stati sono strutturati. Multi-sorted = a pi\'f9 domini/sorti (interi, reali, insiemi definiti da me), first-order structure (perch\'e9 si usa la logica del primo ordine), o anche algebra. Lo stato di una ASM \'e8 un'algebra. Come cambia quest'algebra? Se l'istantanea di un sistema \'e8 un'algebra, la transizione ci fa passare da uno stato, un'algebra, a un altro/a. Anche le transizioni vengono espresse in modo testuale, e sono "regole" che descrivono il cambiamento di funzioni da unos tato al successivo. Abbiamo comunque dei costruttori di regola (modi ben definiti per cambiare lo stato). Esempio: if Condition then Updates. Con "update" intendiamo un aggiornamento dei domini o delle funzioni. Vedremo col tempo diversi costruttori di regole.\par
Con questi modelli, che noi esprimeremo come se fosse uno pseudolinguaggio, avremo a disposizione un ambiendi di sviluppo dove scriverli, un simulatore, che simula la macchina, tecniche di validazione, ovvero attivit\'e0 con cui controllo se il modello soddisfa i requisiti, meccanismi di verifica (via model checking) e generazione di casi di test (si possono generare partendo da modelli). Una ASM pu\'f2 essere vista come una pseudocodifica su strutture dati astratte (ADT). Questo ambiente, che useremo, \'e8 disponibile su github asmeta.github.io/ . Asmeta combina le ASM con meta modelling perch\'e9 questo ambiente \'e8 stato sviluppato usando la meta modellazione. \par
Le funzioni sono sempre definite su domini (impliciti o espliciti). Le regole di transizione le indichiamo come r_nome. Quando scatta una transizione, abbiamo un update, ovvero l'aggiornamento di una funzione. Cambia proprio l'algebra: o aggiorniamo gli insiemi, o aggiorniamo le funzioni.\par
Una ASM \'e8 definita da blocchi ben definitI: (header, body, main rule, initialization).\par
Header: parte iniziale che contiene il nome del file, l'import di alcune librerie, e signature, ovvero la definizione dei nostri domini e delle nostre funzioni. Si usano, in quest'ultimo caso, anche delle etichette. \b Controlled\b0 : funzioni che la macchina pu\'f2 leggere e scrivere. \b Monitored\b0 : i valori di queste funzioni arrivano dall'ambiente, sono input. \b Out\b0 : funzioni che la macchina scrive e che cambiano l'ambiente.\par
Body: le regole di transizione.\par
Main rule: ci permette di mettere in parallelo le regole. Noi siamo in uno stato, che \'e8 la nostra algebra, e se scattano tante transizioni, queste scattano contemporaneamente. NON C'E' SEQUENZA! la main rule con la parola par indica che tutte le transizioni vengono valutate contemporaneamente. C'\'e8 per\'f2 il rischio di creare inconsistenze di valori, visto che queste regole vengono eseguite insieme. Altri problemi sono sollevati dalla gestione di risorse (lock, deadlock). Ci sono situazioni comunque in cui pu\'f2 avere senso che scattino due regole contemporaneamente, basta che aggiornino porzioni separate dell'algebra, altrimenti nascono conflitti. \par
Nelle FSM, esiste un unico stato di controllo che pu\'f2 assumere valori in un insieme finito di un gerto tipo. Nelle ASM lo stato \'e8 pi\'f9 complesso.  Le condizioni di input e le azioni di output, nelle FSM, sono un alfabeto finito. Nelle ASM, l'input \'e8 qualsiasi espressione, e le azioni sono generiche.\par
Abbiamo un linguaggio per scrivere le ASM, ovvero AsmetaL. ha tanti tool tra cui uno per fare editing. Ogni tool ha il prefisso Asmeta-cosa che indica cosa fa il tool. \par
[Normalmente, la main rule amnda tutto in parallelo. Sta a me essere sicuro di non avere situazioni di conflitto.] Aggiungeremo delle invarianti del modello per dire che mai, nel modello, click e complete possono essere entrambe vere, perch\'e9 sarebbe un problema per il nostro sistema (esempio sulle slide).\par
\par
\par
\par
\fs44\par
}
 