{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1040{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qc\f0\fs44\lang16 Modellazione e analisi di sistemi - Appunti\par

\pard\sa200\sl276\slmult1\qj\fs22 Lezione 1 - 28/02/2022\par
\par
Cosa studieremo in questo corso? In questo corso sono richieste competenze di un corso di logica, innanzitutto. Vediamo un attimo il perch\'e9 di questo corso all'interno di un percorso informatico (sicurezza lei dice, ma noi siamo della Gervasi Gang, GG). Abbiamo tutti fatto IS, e abbiamo affrontato il problema dell'attivit\'e0 di testing. Sviluppando software si seguono dei processi, e il software va realizzato in modo ingegneristico e deve avere la "reliability", ovvero affidabilit\'e0, cio\'e8 l'assenza di fallimenti in un lasso di tempo. Quindi, il sw deve comportarsi come vuole il cliente il pi\'f9 a lungo possibile. Se il sw devia dai requisiti, male, quello \'e8 un malfunzionamento. Se per\'f2 non si verificano per un po' di tempo, il sw \'e8 affidabile. Ma ancora meglio sarebbe avere un sw corretto, cio\'e8 che SEMPRE e COMUNQUE si comporta nel modo giusto, il sw. Queste qualit\'e0 vanno dimostrate, e come facciamo a dire che un sw \'e8 affidabile? Normalmente, molto testing. Si tratta di un'attivit\'e0 dove il sw viene esposto a una serie di scenari di esecuzione. Se mostra un malfunzionamento, cio\'e8 fa una cosa diversa da quella che mi aspetto, allora c'\'e8 un bug, e bisogna correggerlo. Fatto ci\'f2, di nuovo testing. Tuttavia \'e8 matematicamente dimostrato che il sw non pu\'f2 essere testato su tutti i possibili input. Quindi il sw viene rilasciato come affidabile, ma ci\'f2 non vuol dire che non esista uno scenario che non dimostra malfunzionamenti, perch\'e9 magari uno scenario negativo io non l'ho beccato. Sarebbe bellissimo dimostrare la correttezza del sw. Come si fa? Con strumenti avanzati e time consuming, ma appunto, non \'e8 banale impiegarli. Ci sono state, comunque, 10 situazioni di programmi con problemi software gravi che non erano stati trovati durante la validazione (testing). Alcuni esempi di fallimenti:\par
The Mats Climate Orbiter Catastrophe: orbita che non arriva su marte ma esplode prima dell'atterraggio in quanto, parte del sw che faceva funzionare la navicella, \'e8 stato commissionato ad un partner inglese che lo ha sviluppato usando i piedi come unit\'e0 di misura, e non il sistema metrico decimale. Quando tutto \'e8 stato messo insieme, non funzionava.\par
Ariane 5 Explosion: razzo che esplode mentre parte. Parte del sw dell'Ariane 4 veniva riciclato, ma i motori non erano "a conoscenza" del fatto che era cambiato il contesto.\par
Hole in the Ozone: della Nasa. Questo buco non \'e8 stato rilevato per tanti anni perch\'e9 la misurazione dell'ozono veniva misurata all'interno di un certo range di misurazione, ma il problema veniva evidenziato solo se si misuravano valori al di fuori di questo range.\par
Deadly Radiation therapy - Therac 25: sistema per la radioterapia, per curare i tumori. Ma per un problema sw le persone venivano sottoposte a radiazioni 100 volte superiori a quelle preventivate. Per un problema software, molte persone sono morte.\par
Il problema insomma \'e8 che abbiamo problemi safety-critical. Quindi riguardano la sicurezza, ma nel senso che il sw quando funziona non causa "cose cattive" all'ambiente (ogni sw \'e8 immperso in un ambiente, sia che si tratti di un ambiente fisico o umano). Questa era la sefety. La security invece \'e8 quando \'e8 l'ambiete a creare problemi al sistema. L'ambiente \'e8 vulnerabile, e quindi anche il sistema lo \'e8. Quando parliamo di sicurezza qui, intendiamo safety. I sistemi allora li distinguiamo tra safety critical e security critical. i primi sono tali per cui un malfunzionamento pu\'f2 avere conseguenze negative per le persone. Nello standard IEEE, \'e8 evidenziato che nel processo di sviluppo di sw medico, ci deve essere una fase di verifica (5.5). Ci sono vari enti predisposti, nel mondo, che richiedono una documentazione piena di evidenze e prove tali da provare che il sw sia sicuro. La fase di verifica, oltre a quella di testing, \'e8 necessaria. A dicembre del 2021, sono stare rilasciate patch di sicurezza per Windows. Pi\'f9 di 60 vulnerabilit\'e0 sono state corrette (spoofing, DoS, Elevation of Privilege, etc.). \par
Esistono persino modelli di sviluppo software security-critical (Capability Maturity Model Integration), che distingue verifica da testing. Quindi un prodotto buono deve essere safety e security critical. Per fare ci\'f2, serve la verifica. In questo corso vedremo come approcciarci al problema di verifica (on \'e8 testing o validazione). E' una attivit\'e0 human-intensive e richiede molte pi\'f9 skill. Noi vogliamo affrontare problemi di verifica per la safety.\par
Quindi, che faremo in questo corso? Presenteremo le tecniche per la modellazione everifica formale di sistemi hw/sw. hw/sw sono sistemi embedded, cio\'e8 hw che si interfaccia col sw. Dovremo fare modellazione e verifica formale insomma. Pensiamo al testing: se non ho il sw, non riesco a fare testing. Anche qui ci serve un manufatto su cui fare verifica: si tratta dei \b modelli. \b0 Useremo i linguaggi di specifica per scrivere modelli. Pensali come lingue con cui traduciamo i requisiti in qualcosa che tutti possiamo comprendere. Poi abbiamo bisogno di fondamenti teorici e metodologie di analisi. Quindi, linguaggi di specifica, come usarli, come fare attivit\'e0 di verifica e come usare strumenti automatici.\par
Impareremo due categorie di linguaggi di specifica: uno sugli automi e uno pi\'f9 simile alla logica (logica temporale).\par
Come analisi, distingueremo tra validazione e verifica (quest'ultima pi\'f9 forte). Come linguaggi ne vedremo due, uno basato sugli automi e uno sulla logica temporale. In un caso, modello il sistema come macchina che esegue. Nell'altro, si modella il sistema sulla base di propriet\'e0 che devono essere soddisfatte. Sugli automi, ripasseremo velocemente Abstract State Machine, un tipo particoalre di automa. Useremo anche un ambiente che ne permette la scrittura di scenari, verifica, etc.. Questi due mega-argomenti dei linguaggi poi si fonderanno insieme: avremo l'automa, le propriet\'e0 da verificare e i tool che verificano automaticamente.\par
Il tool che useremo sar\'e0 NuSMV, per scrivere le propriet\'e0. Faremo model checking e specificheremo propriet\'e0, tra cui: di raggiungibilit\'e0, di safety, di liveness, di fairness e assenza di deadlock. Liveness vuol dire che se un client chiede un servizio a un server, questo prima o poi glielo concede. Per garantire che una propriet\'e0 \'e8 vera, il sistema deve cercare di dimostrare quella propriet\'e0 in tutte le configurazioni in cui si pu\'f2 trovare. C'\'e8 anche, nei model checker, il problema della state explosion (non c'\'e8 abbastanza memoria per dimostrare tutto). Si pu\'f2 risolvere tagliando una parte del modello.\par
Dove studiare?\par
Abstract State Machines: a method for high-level system degind and analysis\par
Logic in Computer Science: modelling and reasoning about systems (2nd edition, 2004)\par
System and Software Verification model-checking techniques and tools\par
Software Reliability methods (per dopo il corso)\par
Esame: scritto e prova pratica. Domande e esercizi. La prova di laboratorio consiste nel dimostrare di saper usare l'ambiente attorno alle ASM. La prova scritta sono domande o esercizi.\par
\par
Cosa sono i metodi formali?\par
Si tratta di notazioni rigorose. Quando voglio esprimere in una logica normale "sto facendo lezione e c'\'e8 il sole", io sintentizzo le proposizioni (verbo, soggetto e complemento) con una lettera proposizionale e le unisco con operatori logici. Questo crea univocit\'e0 e ammazza l'ambiguit\'e0. Descriviamo insomma il nostro sistema in termini rigorosi e matematici, che ha simboli e significato (sintassi e semantica) [P and Q \'e8 un \b termine\b0 ]. Tutti i linguaggi avranno una notazione e un significato, che dobbiamo conoscere per costruire un modello, che descrive un sistema che fa calcoli. Ora, non bisogna essere per forza dei logici o matematici per fare cio\'f2: basta abituarsi a usare un nuovo linguaggio, come se fosse un linguaggio di programmazione. Ci sono poi tecniche per analizzare sistemi, che hanno un fondamento matematico. Ci sono insomma regole di dimostrazione che mi permettono di trasformare un predicato in un T o F. E lo posso fare perch\'e9 il mio modello supporta questo tipo di approccio. Insomma, ogni metodo formale \'e8 accompagnato da un metodo di verifica. Ora, modellare implica astrarre: cerchiamo di astrarre i dettagli dai requisiti per estrarre il vero comportamento del sistema, quello che davvero ci interessa. [UML non \'e8 un modello formale, altrimenti avrebbe accantoa  se approcci o tecniche per fare analisi, che invece non ha]. I vantaggi nell'uso dei metodi formali sono che possiamo descrivere il sistema in modo non ambiguo e univoco. Tutti insomma interpretiamo i requisiti allo stesso modo. Ogni modello inoltre va provato essere corretto, e abbiamo tecniche per farlo. Scrivendo dei modelli potremmo introdurre errori, ma poi possiamo trovarli grazie a questi strumenti e modificare il modello o i requisiti. A volte il modello va bene rispetto ai requisiti, ma dobbiamo cambiare i requisiti.\par
Quindi, scriviamo modelli con metodi formali: ma quanti metodi formali ci sono? Tantissimi. Non \'e8 come UML (unified... \'e8 uno standard aziendale), non ci sono standard. Ci\'f2 nonostante, questi formalismi possiamo dividerli in due categorie:\par
FORMALISMI OPERAZIONALI: descriviamo la macchina come un oggetto che computa. Mi dice come fare qualcosa per raggiungere lo scopo. Abbiamo: Abstract State machines, B method, Z method, SCR (Software Cost Reduction), Reti di Petri. Sono utili se vogliamo seguire la computazione del sistema, l'evoluzione insomma. Utili per la validazione.\par
FORMALISMI OPERAZIONALI: descriviamo un sistema in termini di propriet\'e0 che il sistema deve rispettare. Non mi dice come fare, mi dice cosa voglio. Abbiamo: Logica Temporale, Trio, Algebre dei processi. Ci servono per capire le propriet\'e0 che vogliamo soddisfare. Utili per la verifica.\par
Validazione: simile al testing (anzi, il testing \'e8 una forma di validazione). Il sistema soddisfa i requisiti specificati dal cliente.\par
Verifica: processo di valutare un sistema o una componente per determinare se i prodotti di una data fase di sviluppo sodisfano le propriet\'e0 imposte allo stato di tale fase. Si fa con dimostrazione di propriet\'e0, che di solito vengono effettuate mediante theorem prover e model checker. Model Checker: Modello + propriet\'e0 in pasto a una macchina = verifica, controesempio o memory exceeded. Theorem Prover: Modello + propriet\'e0 in pasto a una macchina, ma "tengo la mano" al dimostratore. L'utente insomma deve intervenire. Spesso con un theorem prover si arriva a un "dunque": siamo noi a dimostrare, quindi scegliamo un ramo di dimostrazione, e se ci porta a errori, possiamo fare backtracking. Noi faremo il model checker. [corso di Metodi Formali per fare anche theorem prover].\par
Cattivi preconcetti: la gente spesso diffida dall'usare i metodi formali, perch\'e9 pensa siano strettamente usati dai matematici. Inoltre si pensa che il processo di verifica sia soggetto ad errori: \'e8 vero, ma se non lo fai non hai la certificazione. Usare metodi formali, inoltre, rallenta lo sviluppo, ma se poi il prodotto \'e8 anche verificato posso provarne la correttezza, e quindi l'affidabilit\'e0 (no bug). \par
Esagerazioni: c'\'e8 chi pensa che la verifica formale sia il top che si pu\'f2 fare. Beh attenzione, perch\'e9 se io provo propriet\'e0 su un modello sbagliato, io non ho fatto niente praticamente. Insomma, non basta un modello e delle propriet\'e0 da provare. I modelli non sempre catturano i requisiti, bisogna fare attenzione. Poi, si dice anche che con la verifica il sw \'e8 sicuro (safety). In realt\'e0 per la complessit\'e0 odierna dei sw non si pu\'f2 avere la prova che l'intero sw sia corretto. Possiamo garantire l'assenza di fallimenti solo su piccoli pezzi del sistema, per l'intero \'e8 follia. Infine, si dice che il testing \'e8 il solo metodo usato nella pratica dalle industrie. Non \'e8 vero, anche la NASA lavora ai metodi formali, quindi sono importanti ANCHE loro.\par
Ebbene, impareremo: processo, come scrivere i modelli. La notazione appropriata, cio\'e8 ASM e Logica temporale. Infine i tools, ASMETA (ASM) e NuSVM (model checker e propriet\'e0 temporali). Ci saranno esercitazioni durante le lezioni di teoria. La prossima volta, ripasseremo le ASM. Le ASM sono un po' diverse dall SM che conosco: scriveremo praticamente un programma, non un diagramma. \par
\par
\par
\par
\par
\fs44\par
}
 