{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1040{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.22000}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qc\f0\fs44\lang16 Modellazione e analisi di sistemi - Appunti\par

\pard\sa200\sl276\slmult1\qj\fs22 Lezione 1 - 28/02/2022\par
\par
Cosa studieremo in questo corso? In questo corso sono richieste competenze di un corso di logica, innanzitutto. Vediamo un attimo il perch\'e9 di questo corso all'interno di un percorso informatico (sicurezza lei dice, ma noi siamo della Gervasi Gang, GG). Abbiamo tutti fatto IS, e abbiamo affrontato il problema dell'attivit\'e0 di testing. Sviluppando software si seguono dei processi, e il software va realizzato in modo ingegneristico e deve avere la "reliability", ovvero affidabilit\'e0, cio\'e8 l'assenza di fallimenti in un lasso di tempo. Quindi, il sw deve comportarsi come vuole il cliente il pi\'f9 a lungo possibile. Se il sw devia dai requisiti, male, quello \'e8 un malfunzionamento. Se per\'f2 non si verificano per un po' di tempo, il sw \'e8 affidabile. Ma ancora meglio sarebbe avere un sw corretto, cio\'e8 che SEMPRE e COMUNQUE si comporta nel modo giusto, il sw. Queste qualit\'e0 vanno dimostrate, e come facciamo a dire che un sw \'e8 affidabile? Normalmente, molto testing. Si tratta di un'attivit\'e0 dove il sw viene esposto a una serie di scenari di esecuzione. Se mostra un malfunzionamento, cio\'e8 fa una cosa diversa da quella che mi aspetto, allora c'\'e8 un bug, e bisogna correggerlo. Fatto ci\'f2, di nuovo testing. Tuttavia \'e8 matematicamente dimostrato che il sw non pu\'f2 essere testato su tutti i possibili input. Quindi il sw viene rilasciato come affidabile, ma ci\'f2 non vuol dire che non esista uno scenario che non dimostra malfunzionamenti, perch\'e9 magari uno scenario negativo io non l'ho beccato. Sarebbe bellissimo dimostrare la correttezza del sw. Come si fa? Con strumenti avanzati e time consuming, ma appunto, non \'e8 banale impiegarli. Ci sono state, comunque, 10 situazioni di programmi con problemi software gravi che non erano stati trovati durante la validazione (testing). Alcuni esempi di fallimenti:\par
The Mats Climate Orbiter Catastrophe: orbita che non arriva su marte ma esplode prima dell'atterraggio in quanto, parte del sw che faceva funzionare la navicella, \'e8 stato commissionato ad un partner inglese che lo ha sviluppato usando i piedi come unit\'e0 di misura, e non il sistema metrico decimale. Quando tutto \'e8 stato messo insieme, non funzionava.\par
Ariane 5 Explosion: razzo che esplode mentre parte. Parte del sw dell'Ariane 4 veniva riciclato, ma i motori non erano "a conoscenza" del fatto che era cambiato il contesto.\par
Hole in the Ozone: della Nasa. Questo buco non \'e8 stato rilevato per tanti anni perch\'e9 la misurazione dell'ozono veniva misurata all'interno di un certo range di misurazione, ma il problema veniva evidenziato solo se si misuravano valori al di fuori di questo range.\par
Deadly Radiation therapy - Therac 25: sistema per la radioterapia, per curare i tumori. Ma per un problema sw le persone venivano sottoposte a radiazioni 100 volte superiori a quelle preventivate. Per un problema software, molte persone sono morte.\par
Il problema insomma \'e8 che abbiamo problemi safety-critical. Quindi riguardano la sicurezza, ma nel senso che il sw quando funziona non causa "cose cattive" all'ambiente (ogni sw \'e8 immperso in un ambiente, sia che si tratti di un ambiente fisico o umano). Questa era la sefety. La security invece \'e8 quando \'e8 l'ambiete a creare problemi al sistema. L'ambiente \'e8 vulnerabile, e quindi anche il sistema lo \'e8. Quando parliamo di sicurezza qui, intendiamo safety. I sistemi allora li distinguiamo tra safety critical e security critical. i primi sono tali per cui un malfunzionamento pu\'f2 avere conseguenze negative per le persone. Nello standard IEEE, \'e8 evidenziato che nel processo di sviluppo di sw medico, ci deve essere una fase di verifica (5.5). Ci sono vari enti predisposti, nel mondo, che richiedono una documentazione piena di evidenze e prove tali da provare che il sw sia sicuro. La fase di verifica, oltre a quella di testing, \'e8 necessaria. A dicembre del 2021, sono stare rilasciate patch di sicurezza per Windows. Pi\'f9 di 60 vulnerabilit\'e0 sono state corrette (spoofing, DoS, Elevation of Privilege, etc.). \par
Esistono persino modelli di sviluppo software security-critical (Capability Maturity Model Integration), che distingue verifica da testing. Quindi un prodotto buono deve essere safety e security critical. Per fare ci\'f2, serve la verifica. In questo corso vedremo come approcciarci al problema di verifica (on \'e8 testing o validazione). E' una attivit\'e0 human-intensive e richiede molte pi\'f9 skill. Noi vogliamo affrontare problemi di verifica per la safety.\par
Quindi, che faremo in questo corso? Presenteremo le tecniche per la modellazione everifica formale di sistemi hw/sw. hw/sw sono sistemi embedded, cio\'e8 hw che si interfaccia col sw. Dovremo fare modellazione e verifica formale insomma. Pensiamo al testing: se non ho il sw, non riesco a fare testing. Anche qui ci serve un manufatto su cui fare verifica: si tratta dei \b modelli. \b0 Useremo i linguaggi di specifica per scrivere modelli. Pensali come lingue con cui traduciamo i requisiti in qualcosa che tutti possiamo comprendere. Poi abbiamo bisogno di fondamenti teorici e metodologie di analisi. Quindi, linguaggi di specifica, come usarli, come fare attivit\'e0 di verifica e come usare strumenti automatici.\par
Impareremo due categorie di linguaggi di specifica: uno sugli automi e uno pi\'f9 simile alla logica (logica temporale).\par
Come analisi, distingueremo tra validazione e verifica (quest'ultima pi\'f9 forte). Come linguaggi ne vedremo due, uno basato sugli automi e uno sulla logica temporale. In un caso, modello il sistema come macchina che esegue. Nell'altro, si modella il sistema sulla base di propriet\'e0 che devono essere soddisfatte. Sugli automi, ripasseremo velocemente Abstract State Machine, un tipo particoalre di automa. Useremo anche un ambiente che ne permette la scrittura di scenari, verifica, etc.. Questi due mega-argomenti dei linguaggi poi si fonderanno insieme: avremo l'automa, le propriet\'e0 da verificare e i tool che verificano automaticamente.\par
Il tool che useremo sar\'e0 NuSMV, per scrivere le propriet\'e0. Faremo model checking e specificheremo propriet\'e0, tra cui: di raggiungibilit\'e0, di safety, di liveness, di fairness e assenza di deadlock. Liveness vuol dire che se un client chiede un servizio a un server, questo prima o poi glielo concede. Per garantire che una propriet\'e0 \'e8 vera, il sistema deve cercare di dimostrare quella propriet\'e0 in tutte le configurazioni in cui si pu\'f2 trovare. C'\'e8 anche, nei model checker, il problema della state explosion (non c'\'e8 abbastanza memoria per dimostrare tutto). Si pu\'f2 risolvere tagliando una parte del modello.\par
Dove studiare?\par
Abstract State Machines: a method for high-level system degind and analysis\par
Logic in Computer Science: modelling and reasoning about systems (2nd edition, 2004)\par
System and Software Verification model-checking techniques and tools\par
Software Reliability methods (per dopo il corso)\par
Esame: scritto e prova pratica. Domande e esercizi. La prova di laboratorio consiste nel dimostrare di saper usare l'ambiente attorno alle ASM. La prova scritta sono domande o esercizi.\par
\par
Cosa sono i metodi formali?\par
Si tratta di notazioni rigorose. Quando voglio esprimere in una logica normale "sto facendo lezione e c'\'e8 il sole", io sintentizzo le proposizioni (verbo, soggetto e complemento) con una lettera proposizionale e le unisco con operatori logici. Questo crea univocit\'e0 e ammazza l'ambiguit\'e0. Descriviamo insomma il nostro sistema in termini rigorosi e matematici, che ha simboli e significato (sintassi e semantica) [P and Q \'e8 un \b termine\b0 ]. Tutti i linguaggi avranno una notazione e un significato, che dobbiamo conoscere per costruire un modello, che descrive un sistema che fa calcoli. Ora, non bisogna essere per forza dei logici o matematici per fare cio\'f2: basta abituarsi a usare un nuovo linguaggio, come se fosse un linguaggio di programmazione. Ci sono poi tecniche per analizzare sistemi, che hanno un fondamento matematico. Ci sono insomma regole di dimostrazione che mi permettono di trasformare un predicato in un T o F. E lo posso fare perch\'e9 il mio modello supporta questo tipo di approccio. Insomma, ogni metodo formale \'e8 accompagnato da un metodo di verifica. Ora, modellare implica astrarre: cerchiamo di astrarre i dettagli dai requisiti per estrarre il vero comportamento del sistema, quello che davvero ci interessa. [UML non \'e8 un modello formale, altrimenti avrebbe accantoa  se approcci o tecniche per fare analisi, che invece non ha]. I vantaggi nell'uso dei metodi formali sono che possiamo descrivere il sistema in modo non ambiguo e univoco. Tutti insomma interpretiamo i requisiti allo stesso modo. Ogni modello inoltre va provato essere corretto, e abbiamo tecniche per farlo. Scrivendo dei modelli potremmo introdurre errori, ma poi possiamo trovarli grazie a questi strumenti e modificare il modello o i requisiti. A volte il modello va bene rispetto ai requisiti, ma dobbiamo cambiare i requisiti.\par
Quindi, scriviamo modelli con metodi formali: ma quanti metodi formali ci sono? Tantissimi. Non \'e8 come UML (unified... \'e8 uno standard aziendale), non ci sono standard. Ci\'f2 nonostante, questi formalismi possiamo dividerli in due categorie:\par
FORMALISMI OPERAZIONALI: descriviamo la macchina come un oggetto che computa. Mi dice come fare qualcosa per raggiungere lo scopo. Abbiamo: Abstract State machines, B method, Z method, SCR (Software Cost Reduction), Reti di Petri. Sono utili se vogliamo seguire la computazione del sistema, l'evoluzione insomma. Utili per la validazione.\par
FORMALISMI OPERAZIONALI: descriviamo un sistema in termini di propriet\'e0 che il sistema deve rispettare. Non mi dice come fare, mi dice cosa voglio. Abbiamo: Logica Temporale, Trio, Algebre dei processi. Ci servono per capire le propriet\'e0 che vogliamo soddisfare. Utili per la verifica.\par
Validazione: simile al testing (anzi, il testing \'e8 una forma di validazione). Il sistema soddisfa i requisiti specificati dal cliente.\par
Verifica: processo di valutare un sistema o una componente per determinare se i prodotti di una data fase di sviluppo sodisfano le propriet\'e0 imposte allo stato di tale fase. Si fa con dimostrazione di propriet\'e0, che di solito vengono effettuate mediante theorem prover e model checker. Model Checker: Modello + propriet\'e0 in pasto a una macchina = verifica, controesempio o memory exceeded. Theorem Prover: Modello + propriet\'e0 in pasto a una macchina, ma "tengo la mano" al dimostratore. L'utente insomma deve intervenire. Spesso con un theorem prover si arriva a un "dunque": siamo noi a dimostrare, quindi scegliamo un ramo di dimostrazione, e se ci porta a errori, possiamo fare backtracking. Noi faremo il model checker. [corso di Metodi Formali per fare anche theorem prover].\par
Cattivi preconcetti: la gente spesso diffida dall'usare i metodi formali, perch\'e9 pensa siano strettamente usati dai matematici. Inoltre si pensa che il processo di verifica sia soggetto ad errori: \'e8 vero, ma se non lo fai non hai la certificazione. Usare metodi formali, inoltre, rallenta lo sviluppo, ma se poi il prodotto \'e8 anche verificato posso provarne la correttezza, e quindi l'affidabilit\'e0 (no bug). \par
Esagerazioni: c'\'e8 chi pensa che la verifica formale sia il top che si pu\'f2 fare. Beh attenzione, perch\'e9 se io provo propriet\'e0 su un modello sbagliato, io non ho fatto niente praticamente. Insomma, non basta un modello e delle propriet\'e0 da provare. I modelli non sempre catturano i requisiti, bisogna fare attenzione. Poi, si dice anche che con la verifica il sw \'e8 sicuro (safety). In realt\'e0 per la complessit\'e0 odierna dei sw non si pu\'f2 avere la prova che l'intero sw sia corretto. Possiamo garantire l'assenza di fallimenti solo su piccoli pezzi del sistema, per l'intero \'e8 follia. Infine, si dice che il testing \'e8 il solo metodo usato nella pratica dalle industrie. Non \'e8 vero, anche la NASA lavora ai metodi formali, quindi sono importanti ANCHE loro.\par
Ebbene, impareremo: processo, come scrivere i modelli. La notazione appropriata, cio\'e8 ASM e Logica temporale. Infine i tools, ASMETA (ASM) e NuSVM (model checker e propriet\'e0 temporali). Ci saranno esercitazioni durante le lezioni di teoria. La prossima volta, ripasseremo le ASM. Le ASM sono un po' diverse dall SM che conosco: scriveremo praticamente un programma, non un diagramma. \par
\par
Lezione 2 - 07/03/2022\par
Automi per la specifica di sistemi (ripasso).\par
Logica proposizionale e dei predicati -> da ripassare (l'ho gi\'e0 quasi finito di fare).\par
La scorsa volta abbiamo visto che studieremo due formalismi utili a modellare e poi fare analisi su questi modelli. Il primo modello sono le ASM, e riprendono gli automi, e il secondo \'e8 la logica temporale. Entrambi questi modelli vanno basati sul concetto di automi. I nostri formalismi modellano un sistema, e si basano sul concetto di stato come istantanea di un sistema e il passaggio da uno stato al successivo mediante una transizione. Gli automi nascono come primo esempio di macchine capaci di riconoscere linguaggi, ma in generale vengono usati per modellare i sistemi. Prima di vedere i formalismi che useremo, ripassiamo gli automi. Questo concetto di automa infatti \'e8 nella pratica molto usato per fare uno sketch di un sistema che poi andr\'e0 implementato.\par
Un automa \'e8 matematicamente definito come una tupla di ingredienti:\par
-S, l'insieme degli stati, che sono in numero finito.\par
-I, insieme finito di eventi di input.\par
-sigma: S x I -> S, che \'e8 la funzione di transizione.\par
Ovvero, se sono in uncerto stato e applico un certo input, vado in uno stato successivo. Si rappresenta graficamente mediante un disegno dove gli stati sono dei cerchi e le transizioni (della funzione di transizione) sono delle frecce. Se vogliamo segnare uno stato iniziale, mettiamo una freccia che entra nello stato iniziale e che proviene dal "niente". Queste sono le macchine "di base", cio\'e8 che rispondono solo agli input. Vorremmo per\'f2 anche automi che cambiano l'ambiente, ma questo formalismo \'e8 troppo semplice per farlo.\par
Estensioni: macchine di Mealy. Le transizioni sono tuple del tipo (stato di partenza, input, output, stato di arrivo). Ovvero, dato uno stato e un input, va in un altro stato esponendo l'output sulla transizione. In una transizione, si scrive input/output per specificare che, a fronte dell'evento di input verificatosi, non solo si cambia di stato (basta seguire la direzione della freccia), ma si verifica anche un'azione rappresentata dall'output.\par
Tuttavia, io, con questo formalismo, non posso modellare macchine che, ad esmepio, mi scambiano monete. Tipo, immetto 10 monete da 10 cents e ricevo una moneta da un euro. Si tratta s\'ec di una macchina che ha input e output, ma che ha bisogno di ricordarsi delle cose. Le amcchine di Mealy non hanno memoria insomma. \par
L'estensione successiva \'e8 quindi quella della macchine a stati finiti estese. La transizione \'e8 ora una tupla (stato di partenza, input, output, guardia sulla memoria, azione di aggiornamento della memoria, stato di arrivo). La rappresentazione "a grafo" \'e8 come prima, ma abbiamo [coin=1] per le guardie, seguite dalle azioni del tipo "coin:=0". In pratica: se avviene un certo input e la guardia \'e8 vera, compio l'azione, emetto l'output e passo allo stato d'arrivo. Bisogna fare attenzione nelle guardie, perch\'e9 potremmo generare automi deterministici o non deterministici. Da notare come stiamo aggiungendo informazioni sulle transizioni. Un'osservazione: glis tati sono sempre cose semplici. Hanno solo un nome che raprpesenta la configurazione del sistema in un certo momento. Quello che non si riesce a fare con queste macchine sono i Sistemi Distribuiti. Immaginiamo un sistema produttore-consumatore. Potrei modellarlo con queste macchine, ma il numero di transizione esploderebbe. Perch\'e9 in uno stato devo tenere conto di cosa c'\'e8 nel consumatore, nel produttore e nel magazzino (?). Il passo successivo \'e8 quindi quello di definire le macchine di comunicazione.\par
Nelle macchine di comunicazione, ho:\par
-Una coppia (C,P), con C che sono i canali usati dai P processi per passarsi informazioni.\par
Dobbiamo immaginarci di avere tanti pezzi che comunicano tra di loro e possono anche comunicare con l'ambiente.\par
-Transizioni che sono: (s, c?i, s'), dove un pezzo legge informazioni da un canale (legge l'input i), (s, c!o, s'), dove invece si scrive su un canale l'output o e si passa a un altro stato. (s, null, s') per indicare che c'\'e8 stata una transizione da uno stato all'altro in un pezzo del sistema, ma non ha effetto sul canale.\par
E' arrivato poi UML con i suoi diagrammi, tra cui diagrammi per le amcchine di stato. Viene modellata come:\par
-Stati che hanno un nome e azioni di ingresso, l'attivit\'e0 che si compie mentre si \'e8 in quello stato, di uscita e eventi che, sulla base di alcune condizioni, compie azioni.\par
-Le transizioni anch'esse hanno un evento (l'input), una condizione (eventualmente) e un'azione.\par
UML cattura le macchine per Stati Finiti dividendo lo spazio in regioni parallele, dove ciascuna di esse ha una FSM che fa il suo lavoro e volendo comunica con le altre. In UML, la lettura di input \'e8 segnata come <<signal>>.\par
Ma la storia degli automi non finisce qua. Le ASM che studieremo sono un esempio di automa. Dobbiamo capire che il sistema ha una configurazione, una istantanea, che \'e8 lo stato, e transizioni che modificano lo stato. Tuttavia, per noi, questo stato che fino ad ora aveva semplicemente un nome, per noi sar\'e0 pieno di informazioni. Dopo pasqua vedremo anche gli automi di Kripke, dove lo stato \'e8 etichettato da lettere proposizionali. Lo stato, in questo caso, ci dice pi\'f9 che altro cosa \'e8 vero e cosa no in un certo stato (quale propriet\'e0 \'e8 valida in questo momento?).\par
\par
ASM\par
Le Abstract State Machines sono FSM cons"stati generalizzati", ovvero: mentre, finora, lo stato era uno stato cosiddetto "unstructured", ovvero dove non aveva una struttura se non per il nome, da ora in poi glis tati saranno strutturati. Lo stato \'e8 sempre modellato con un tondino (anche se poi lasceremo cadere la notazione grafica), ma in realt\'e0 per noi queste ASM saranno una sorta di pseudo-codifica. Useremo, per scrivere queste SM, un linguaggio di specifica. La principale differenza rispetto alle FSM \'e8 che questi stati sono strutturati. Ma cosa vuol dire? Viuol dire che lo stato diventa un'algebra, o "multi-sorted first-order structures". Io ad esempio voglio modellare un orologio che, in base al tempo corrente, visualizza il tempo in modo distreto ogni delta time. Quindi ho un orologio che, in base al tempo corrente, mi permette di vedere il tempo non in modo continuo ma a interalli di tempo (tipo ogni 5 secondi). Quali informazioni mi modelleranno questo fenomeno? Gli ingredienti che useremo per modellare li prendiamo dalla matematica. Cos'\'e8 un'algebra? Un insieme di simboli che hanno un'interpretazione. Nel nostro esempio, abbiamo la variabile CurrTime di tipo reale per ricordarci del tempo. La difficolt\'e0 di usare queste SM sar\'e0 usare la matematica per catturare quello che vogliamo dire. Poi abbiamo bisogno di qualcosa in cui mettere il tempo da visualizzare: DisplayTime, reale. Poi qualcosa che ci dica ogni quanto il tempo deve aggiornarsi: Delta, un reale (costante). Infine, una funzione + che va da Real x Real -> Real. Queste informazioni sono variabili, costanti. Tutte queste cose insieme costituiscono la mia algebra. Le variabili sono di fatto funzioni 0-arie.\par
Quindi, rappresentiamo lo stato attraverso un'algebra, con insiemi e funzioni. Gli stati sono strutturati. Multi-sorted = a pi\'f9 domini/sorti (interi, reali, insiemi definiti da me), first-order structure (perch\'e9 si usa la logica del primo ordine), o anche algebra. Lo stato di una ASM \'e8 un'algebra. Come cambia quest'algebra? Se l'istantanea di un sistema \'e8 un'algebra, la transizione ci fa passare da uno stato, un'algebra, a un altro/a. Anche le transizioni vengono espresse in modo testuale, e sono "regole" che descrivono il cambiamento di funzioni da unos tato al successivo. Abbiamo comunque dei costruttori di regola (modi ben definiti per cambiare lo stato). Esempio: if Condition then Updates. Con "update" intendiamo un aggiornamento dei domini o delle funzioni. Vedremo col tempo diversi costruttori di regole.\par
Con questi modelli, che noi esprimeremo come se fosse uno pseudolinguaggio, avremo a disposizione un ambiendi di sviluppo dove scriverli, un simulatore, che simula la macchina, tecniche di validazione, ovvero attivit\'e0 con cui controllo se il modello soddisfa i requisiti, meccanismi di verifica (via model checking) e generazione di casi di test (si possono generare partendo da modelli). Una ASM pu\'f2 essere vista come una pseudocodifica su strutture dati astratte (ADT). Questo ambiente, che useremo, \'e8 disponibile su github asmeta.github.io/ . Asmeta combina le ASM con meta modelling perch\'e9 questo ambiente \'e8 stato sviluppato usando la meta modellazione. \par
Le funzioni sono sempre definite su domini (impliciti o espliciti). Le regole di transizione le indichiamo come r_nome. Quando scatta una transizione, abbiamo un update, ovvero l'aggiornamento di una funzione. Cambia proprio l'algebra: o aggiorniamo gli insiemi, o aggiorniamo le funzioni.\par
Una ASM \'e8 definita da blocchi ben definitI: (header, body, main rule, initialization).\par
Header: parte iniziale che contiene il nome del file, l'import di alcune librerie, e signature, ovvero la definizione dei nostri domini e delle nostre funzioni. Si usano, in quest'ultimo caso, anche delle etichette. \b Controlled\b0 : funzioni che la macchina pu\'f2 leggere e scrivere. \b Monitored\b0 : i valori di queste funzioni arrivano dall'ambiente, sono input. \b Out\b0 : funzioni che la macchina scrive e che cambiano l'ambiente.\par
Body: le regole di transizione.\par
Main rule: ci permette di mettere in parallelo le regole. Noi siamo in uno stato, che \'e8 la nostra algebra, e se scattano tante transizioni, queste scattano contemporaneamente. NON C'E' SEQUENZA! la main rule con la parola par indica che tutte le transizioni vengono valutate contemporaneamente. C'\'e8 per\'f2 il rischio di creare inconsistenze di valori, visto che queste regole vengono eseguite insieme. Altri problemi sono sollevati dalla gestione di risorse (lock, deadlock). Ci sono situazioni comunque in cui pu\'f2 avere senso che scattino due regole contemporaneamente, basta che aggiornino porzioni separate dell'algebra, altrimenti nascono conflitti. \par
Nelle FSM, esiste un unico stato di controllo che pu\'f2 assumere valori in un insieme finito di un gerto tipo. Nelle ASM lo stato \'e8 pi\'f9 complesso.  Le condizioni di input e le azioni di output, nelle FSM, sono un alfabeto finito. Nelle ASM, l'input \'e8 qualsiasi espressione, e le azioni sono generiche.\par
Abbiamo un linguaggio per scrivere le ASM, ovvero AsmetaL. ha tanti tool tra cui uno per fare editing. Ogni tool ha il prefisso Asmeta-cosa che indica cosa fa il tool. \par
[Normalmente, la main rule amnda tutto in parallelo. Sta a me essere sicuro di non avere situazioni di conflitto.] Aggiungeremo delle invarianti del modello per dire che mai, nel modello, click e complete possono essere entrambe vere, perch\'e9 sarebbe un problema per il nostro sistema (esempio sulle slide).\par
\par
Lezione 3 - 10/03/2022\par
La scorsa volta abbiamo visto un paio di esempi e li abbiamo visti come macchine a stati, e poi abbiamo abbozzato un modello in ASM. Le ASM ereditano dalle SM il concetto di stato e transizione. Ma nelle ASM abbiamo un algebra per ogni stato, cio\'e8 funzioni e insiemi, e le transizioni sono date da regole.\par
Allora, noi abbiamo funzioni, ma uno stato pu\'f2 essere rappresentato come una locazione. Ad ogni stato s sono asccociati valori di qualsiasi tipo conservati in una locazione (come un cassetto). Uno stato \'e8 un insieme di cassetti, e ciascuno di loro ha unu nome che ha al suo interno un valore. Se uno stato quindi \'e8 questo insieme di cassetti con dentro valori, quando io cambio stato cambio algebra, ovvero insieme di cassetti. Bene, se l'insieme di cassetti \b non cambia\b0 , allora cambia per forza il contenuto. In questi casi, cambiano semplicemente i valori delle locazioni. Insomma, la foto del nostro sistema \'e8 un insieme di locazioni (funzioni con argomento). Una locazione, insomma, \'e8 la coppia (f, (v1, v2, ..., vn)), con f nome di funzione e (v1, v2, ..., vn) i suoi argomenti. f \'e8 il nome, i vari v i suoi argomenti. Di funzioni non se ne creano n\'e9 distruggono nell'esecuzione di una ASM. Al massimo vengono aggiornati i valori dei cassetti. In uno stato s, una locazione ha un valore: l'interpretazione della funzione nello stato. Data una locazione (cassetto), possiamo trovare il valore contenuto al suo interno. Se nella locazione loc ho al suo interno il valore a, allora f(v1, ..., vn) ) a. Quando aggiorno il valore di un cassetto, scrivo f(v1, ..., vn) := newval. Quindi, cambia il valore di loc. Quindi, stiamo sempre parlando di stati (insieme di cassetti con valore) e di passaggio di stato, ma non si aggiungono mai funzioni nuove n\'e9 se ne tolgono. Ricorda inoltre che il codice non verr\'e0 eseguito sequenzialmente: tutte le transizioni sono considerate contemporaneamente. Ora, tutto questo va descritto formalmente, e dobbiamo agganciarci alla logica. Quello che arriveremo a fare sar\'e0 descrivere modelli in termini di funzioni e regole che le aggiornano. partendo dalla logica, definiremo lo stato e le transizioni in modo pi\'f9 rigoroso.\par
Partiamo dal vocabolario sommatoria. Un vocabolario \'e8 una collezione finita di nomi di funzioni. Noi distinguere le funzioni tra dinamiche e statiche, a seconda che l'interpretazione del nome della funzione cambia o no da uno stato al successivo. Con "funzione" intendiamo il senso matematico, non informatico nel senso di procedure. Quindi, il vocabolario \'e8 un insieme di simboli (sintassi) a cuia ssociamo un significato (semantica). Dobbiamo insomma dare interpretazioni ai simboli. Se io fisso una volta per tutte il significato di un simbolo, allora quella \'e8 una funzione statica. Se invece a seconda dello stato il significato della funzione cambia (tipo una funzione 0-aria: studenti in aula prima vale 50, poi 0, \'e8 praticamente una variabile) allora sar\'e0 una funzione dinamica. Una variabile, appunto, \'e8 una funzione ad argomenti 0 che cambia nel tempo. Una costante stessa cosa, ma non cambia, quindi \'e8 una funzione statica. \par
Le funzioni statiche di ariet\'e0 0 sono dette costanti. Ci sono tre costanti che si possono usare in tutti i modelli: undef, true e false. L'undef \'e8 usato per poter garantire la totalit\'e0 delle funzioni (ci arriveremo dopo). Altre costanti sono costanti numeriche (i numeri) e altre user-defined. Le funzioni statiche possono comunque avere ariet\'e0 > 0, come +, -, AND e OR. Cio\'e8, l'interpretazione di queste funzioni \'e8 sempre la stessa, indipendentemente dallo stato. Anche qui, posso definire funzioni mie, tipo max(m,n) che \'e8 sempre statica: indipendentemente dal mio stato, il suo significato \'e8 sempre quello di restituirmi il massimo tra n e m.\par
Le funzioni dinamiche sono quelle che cambiano interpretazione di stato in stato. Quelle di ariet\'e0 0 sono praticamente variabili.\par
un esempio di vocabolario SIGMAbool dell'algebra booleana contiene due costanti, 0 e 1, una funzione unaria di nome - (negazione) e due funzioni binarie di nomi + e * (OR e AND). Tutte quelle elencate finora sono funzioni statiche.\par
Fissato un vocabolario, uno stato A del nostro vocabolario \'e8 un insieme non vuoto X, detto superuniverso di A, con le interpretazioni dei nomi delle funzioni di SIGMA. Quindi, posso definire uno stato partendo dal vocabolario e da un significato per i simboli del vocabolario. Se f \'e8 un nome di funzione n-aria di SIGMA, allora la sua interpretazione f^A \'e8 una funzione da X^n a X. Se c \'e8 una costante di SIGMA, allora la sua interpretazione c^A \'e8 un elemento d X.\par
Il superuniverso non pu\'f2 cambiare (per ora). Ma c'\'e8 una sorta di riserva da cui prendo cose che incrementano il dominio (lo vedremo dopo, complicato). Il superuniverso pu\'f2 essere visto come dominio.\par
Quello che scriviamo nei modelli non ha significato finch\'e9 non glielo diamo noi. Fino ad allora, il nostro modello \'e8 un semplice insieme freddo di simboli.\par
Se il mio stato ASM \'e8 un'algebra che definisco a partire dal vocabolario e l'interpretazione dei simboli su un superuniverso X che non cambia, sembra quasi che abbiamo funzioni e un solo dominio: X. Ma io devo poter distinguere diversi domini (tipo pc, sedie, umani...). Come faccio ad avere domini? Il superuniverso va pensato come partizionato in pezzi, sulla base di certe caratteristiche. Ogni partizione \'e8 per noi un dominio, perch\'e9 questo superuniverso \'e8 frammentato in pezzi, e ciascuno di loro \'e8 definito da un nome [funzione caratteristica!!!] cio\'e8, se X = 1,2,3,a,b,mario,pippo, allora il dominio Interi = \{1,2,3\} \'e8 anche una funzione che restituisce True quando x (l'argomento della funzione Interi() ) \'e8 1, 2 o 3, False altrimenti. Quindi, per noi un dominio \'e8 in realt\'e0 la SUA funzione caratteristica! Tutte queste funzioni/domini sono definite sul superuniverso X e restituiscono solo True oppure False. In tutto questo, il fatto che due funzioni restituiscano True per uno stesso elemento non ha importanza.\par
Quindi, dominio = set = universo. Col trucchetto appena descritto, possiamo modellare domini eteorenei nei nostri modelli. Ci sono domini predefiniti ovviamente: Interi, String, Bool, Real, etc.. Ovviamente possiamo anche noi stessi modellare i domini che ci interessano, sia "from scratch" sia partendo da un altro dominio. Scopriremo poi che il tool che useremo \'e8 basato su Java.\par
Vedremo inoltre che le funzioni possono essere ulteriormente classificate. In alcuni casi, il valore di una funzione proviene dall'esterno, mentre in altri casi siamo noi a dare valori alle funzioni, dall'interno insomma.\par
Recuperiamo, dalla logica, anche il concetto di termine. I termini di un vocabolario SIGMA sono espressioni sintattiche costruite in questo modo:\par
- le variabili sono termini\par
- le costanti sono termini\par
- se f \'e8 un simbolo di funzione n-aria di SIGMA e t1, ..., tn sono termini, allora f(t1, ..., tn) \'e8 un termine. \par
I termini di solito si denotano con r, s, t, mentre le variabili come x, y, z. Se un termine non contiene variabili, \'e8 anche detto chiuso. Ovvero, non pu\'f2 variare da uno stato all'altro. In caso contrario, il termine \'e8 aperto. Anche i termini non hanno significato finch\'e9 non gli do un significato/modello/semantica.\par
Cerchiamo ora di capire come scrivere le regole.\par
Cerchiamo di capire il concetto di regola di transizione. Uno stato \'e8 un'algebra, che parte da un vocabolario e un superuniverso. Passando da uno stato al successivo, ovvero, passando da un istante di tempo al successivo, le algebre cambiano. Dobbiamo capire come questi stati astratti vengono aggiornati, e per farlo dobbiamo capire le regole di transizione. Attenzione: non sono le classiche frecce, ma regole. Per costruirle, usiamo costruttori di regole, e avremo tante regole. Tutte le regole insieme sono chiamate "programma ASM". Vedremo che sta a noi scegliere se scrivere tante regole o una sola, e sar\'e0 la main rule che le far\'e0 scattare tutte quante.\par
Ricordiamoci che l'algebra alla fine non \'e8 altro che un insieme di funzioni, di cassetti. Quando passiamo da uno stato all'altro il loro contenuto cambia. Con l'update rule, possiamo cambiare i valori nei cassetti. Un'update rule pu\'f2 essere f(t1, ..., tn) := s (:= !!!!!, = significa invece equivalenza o uguaglianza). In questa regola, f \'e8 un nome di funzione dinamica n-aria di SIGMA, mentre t1, ..., tn e s sono termini di SIGMA. Se la funzione \'e8 0-aria, allora f \'e8 una variabile, e l'aggiornamento sar\'e0 del tipo c:=s. Vediamo ora dei costruttori di regola.\par
Costruttore if-then-else: si tratta di un costrutto di base che dice if phi then R else S. R e S sono entrambe update rule (o anche altre regole, in generale regole arbitrariamente complicate). Se la condizione phi, calcolata logicamente, \'e8 vera, allora si esegure R, altrimenti S.\par
Vediamo ora la classificazione delle funzioni ASM. Si classificano in Base e Derivate. Entrambe possono essere Statiche e Dinamiche. Quelle dinamiche sono: in (monitorate, sono l'input), controllate, condivise e out. Le "in" sono lette dalla macchina, ovvero lei le legge da un oracolo esterno. Sono cio\'e8 lette da M e scritte da env. Le "out" invece sono scritte da M e lette da env. "Controlled" sono invece lette e scritte da M, mentre le "shared" sono lette e scritte da M e env. Quindi, nel costruire i modelli, dobbiamo dichiarare la natura delle nostre funzioni. Una funzione controllata star\'e0 a sinistra di qualche aggiornamento, ovvero assegna a questa un valore, ma pu\'f2 stare anche a destra. [L'ambiente \'e8 tutto quello che non sta nel nostro sistema]. Le funzioni derivate (derived) sono invece simboli definiti da delle legge. L'idea \'e8 di aggiungere un nuovo simbolo al vocabolario, la cui regola che lo descrive la scelgo io. Il suo valore \'e8 preso da una regola applicata ad altre funzioni, e servono a rendere i modelli pi\'f9 leggibili. Ci sono diversi costruttori di regole nelle slide.\par
Skip Rule: skip, ovvero, non fare niente. E' una regola che con carta e penna non serve, ma vedremo che ci pu\'f2 tornare utile come placeholder. La useremo per parsare un certo modello ancora incompleto.\par
Let Rule: let x = r in R(x) (Se R ha parameri, realizza il passaggio per valore). Il significato \'e8: assegna il valore di t a x ed esegui R.\par
let x = f1(f2(f3(y))) in g(x) := 7 \'e8 lo stesso di g(f1(f2(f3(y)))) := 7.\par
Block Rule. La useremo spesso.\par
par\par
\tab R\par
\tab S\par
endpar\par
L'idea \'e8 che tutte le regole tra par e endpar sono eseguite in parallelo. La cosa non banale da digerire \'e8 che, davvero, NON C'E' SEQUENZIALITA'! E' molto simile a VHDL, dove dicevamo che in un processo l'assegnamento a segnali si fa una volta sola alla fine. Cio\'e8:\par
ipotesi: f(5) = 1\par
\tab f(5) := 2\par
\tab g(3) := f(5) --allo stato successivo, g(3) = 1, non 2, perch\'e9 le regole sono fatte in parallelo!\par
(Macro) Call Rule: ci serve per fare chiamate di funzione. Si scrive: r[t1, .., tn]. Se non ci sono argomenti, r[]. Significato. chiama r (una regola con parametri) con argomenti t1, ..., tn. E' proprio una chiamata di procedura. \par
Ancora, la main rule \'e8 il punto di partenza, ed \'e8 spesso una call rule. Conviene sempre cercare di capire prima questa regola, poi tutte le altre.\par
\par
Lezione 4 - 14/03/2022\par
Ricorda che uno stato \'e8 un insieme di locazioni, cio\'e8 funzioni con argomenti attuali (locazioni = cassetti).\par
La block rule serve come costrutto per mettere in parallelo delle regole. La conditional rule serve a eseguire una regola solo se una condizione \'e8 verificata. La let serve solo ad abbreviare una formula da usare in un contesto pi\'f9 ampio. La MacroCall rule serve invece a chiamare altre regole quando ci pare (funzione). Di fatto dichiariamo la regola da qualche parte e poi la richiamiamo. Oggi completiamo la panoramica delle regole con la Seq, la forall e la choose.\par
Seq: aggiunge sequenzialit\'e0 nelle ASM. E' una componente derivata nelle ASM. Forall: permette di applicare lo stesso comportamento a tutti gli elementi di un array. Choose: introduce non determinismo nelle ASM.\par
Sintassi Seq:\par
seq\par
\tab R\par
\tab S\par
endseq\par
Le regole all'interno possono essere tutte quelle che ti pare e usare costruttori di regola diversi. La differenza tra seq e modello di computazione normale nelle ASM, ovvero l'esecuzione in parallelo, \'e8 che il Seq introduce dei "microstati invisibili" tra due stati (quando passo da uno all'altro). \par
f(5) := 2\par
f(3) := f(5)\tab --allo stato successivo f(3) = 2\par
E' un costrutto pericoloso, nel senso che, se abbiamo troppi seq nel nostro programma, abbiamo sbagliato qualcosa nel modello che abbiamo formulato. In generale, quindi, NON LO USARE. A meno che non ci siano situazioni limite in cui ci servono variabili temporanee, come lo swap tra due variabili. Ne vedremo un esempio dopo. In generale, comunque, il seq deve servire solo a snellire il modello quando necessario, non come "shortcut". Un esempio di seq \'e8 il fattoriale.\par
Forall e choose hanno la stessa sintassi: forall/choose x with phi do R[x]. Nel forall, viene eseguita la regola R in parallelo per ogni x che soddisfa phi. Phi pu\'f2 anche ssere true se voglio eseguire un'operazione su tutti glie lementi del dominio. Con la choose, invece, scegliamo un elemento casuale che rispetta le condizioni phi e gli applichiamo la regola R. La choose sceglie sempre valori utili.\par
Una ASM allora la possiamo definire come una terna (SIGMA, A, R).\par
-Sigma: un vocabolario, dei simboli, una signature.\par
Uno stato iniziale A per SIGMA.\par
-Un insieme R di nomi di regole, con un nome di regola di ariet\'e0 zero, la cosiddetta "main rule", che \'e8 l'entry point per l'esecuzione della macchina, e una definizione di regola per ogni nome di regola. La semantica delle regole di transizione \'e8 data dall'insieme di tutti gli aggiornamenti.\par
Ci \'e8 sempre stato detto che in un'algebra le funzioni non vengono n\'e9 create n\'e9 distrutte, e che gli insiemi sono rappresentati come le loro rispettive funzioni caratteristiche. Spesso, nelle computazioni, abbiamo bisogno di dire per\'f2 che un certo dominio \'e8 stato esteso o contratto (come una pila). Dobbiamo quindi modellare l'aggiunta/rimozione di qualcosa che prima non c'era. Bene, questo \'e8 possibile con una nuova regola che ci permette di estendere un dominio. Per aumentare gli elementi dei domini, abbiamo la regola:\par
extend U with x [do] R\par
si tratta di una regola derivata da:\par
import x do\par
\tab U(x) := true seq R\par
"Scegli un elemento x da un insieme predefinito, chiamato "riserva", che \'e8 un insieme di simboli freschi. Togli x dalla riserva e aggingilo al superuniverso. Infine, esegui R." Vediamo sulle slide un esempio di operazioni sullo stack. (Nella rimozione, non facciamo garbage collection, semplicemente rendiamo l'elemento del dominio distaccato da ogni funzione, rendendolo quindi irraggiungibile).\par
Concetto di sensore: funzioni monitorate.\par
\par
\par
\par
\par
\fs44\par
}
 